<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>TI-RTOS Drivers: ADCBufCC26XX.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TI-RTOS Drivers
   &#160;<span id="projectnumber">tidrivers_cc13xx_cc26xx_2_21_01_01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c17777783ce38a5c07940aaaf742f522.html">exports</a></li><li class="navelem"><a class="el" href="dir_f6e916242039e0349c75a086e347d29e.html">tidrivers_cc13xx_cc26xx_2_21_01_01</a></li><li class="navelem"><a class="el" href="dir_66ebce97428d8a203c418c1e1c30b1d0.html">packages</a></li><li class="navelem"><a class="el" href="dir_bb9bb6c41181976c26c510dde001be8f.html">ti</a></li><li class="navelem"><a class="el" href="dir_3272f9f9556099c0b986cb38fa788482.html">drivers</a></li><li class="navelem"><a class="el" href="dir_167c9a72bd38d897d1102afaa614df68.html">adcbuf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ADCBufCC26XX.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ADCBuf driver implementation for a CC26XX analog-to-digital converter. </p>
<p>============================================================================</p>
<h1>Driver include</h1>
<p>The ADCBuf header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_d_c_buf_8h.html">ti/drivers/ADCBuf.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ti/drivers/adc/ADCBufCC26XX.h&gt;</span></div>
</div><!-- fragment --><h1>Overview</h1>
<p>This is a CC26XX specific implementation of the generic TI-RTOS ADCBuf driver. The generic ADCBuf API specified in <a class="el" href="_a_d_c_buf_8h.html" title="ADCBuf driver interface. ">ti/drivers/ADCBuf.h</a> should be called by the application, not the device specific implementation in ti/drivers/adcbuf/ADCBufCC26XX. The board file defines the device specific configuration and casting in the general API ensures the correct device specific functions are called. You should specify an <a class="el" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html" title="CC26XX specfic extension to ADCBuf_Params. ">ADCBufCC26XX_ParamsExtension</a> in the custom field of the <a class="el" href="struct_a_d_c_buf___params.html" title="ADC Parameters. ">ADCBuf_Params</a> that suits your application. The default settings work for many, but not all, usecases.</p>
<h1>General Behavior</h1>
<p>A timer and the DMA are used to trigger the ADC and fill a buffer in the background (in hardware) at a specified frequency. The application may execute other tasks while the hardware handles the conversions. In contrast to the standard ti/drivers/ADC driver, this driver allows for precise sampling of waveforms.</p>
<table class="doxtable">
<tr>
<th>Driver </th><th>Number of samples needed in one call  </th></tr>
<tr>
<td><a class="el" href="_a_d_c_8h.html" title="ADC driver interface. ">ADC.h</a> </td><td>1 </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html" title="ADCBuf driver interface. ">ADCBuf.h</a> </td><td>&gt; 1 </td></tr>
</table>
<p>This ADCBuf driver provides an API interface to using the analog-to-digital converter directly from the CM3 without going through the sensor controller. The sensor controller can still use the ADC, support for sharing the ADC resource between the sensor controller and the CM3 is built into the driver. There is a hardware semaphore that the driver must aqcuire before beginning any number of conversions. This same hardware semaphore also prevents the simultaneous use of this driver and the basic ADC driver.</p>
<p>The ADC drivers supports making between one and 1024 measurements once or continuous measuring with returned buffer sizes between one and 1024 measurements.</p>
<p>The application should call <a class="el" href="_a_d_c_buf_8h.html#a88a0ab421304465b22417a7adef6c0c2" title="This function initializes the ADC module. This function must. ">ADCBuf_init()</a> once by the application to set the isOpened flag to false, indicating that the driver is ready to use.</p>
<p>The ADC driver is opened by calling <a class="el" href="_a_d_c_buf_8h.html#a0b63bca2e8f8e5b58f0c657ac662c97b" title="This function opens a given ADCBuf peripheral. ">ADCBuf_open()</a> which will set up interrupts and configure the internal components of the driver. However, the ADC hardware or analog pins are not yet configured, since the sensor controller or basic ADC driver might be using the ADC.</p>
<p>In order to perform an ADC conversion, the application should call <a class="el" href="_a_d_c_buf_8h.html#a762253a94875258c5a71b591f03f9d97" title="This function starts a set of conversions on one or more channels. ">ADCBuf_convert()</a>. This call will request the ADC resource, configure the ADC, set up the DMA and GPTimer, and perform the requested ADC conversions on the selected DIO or internal signal. The DIO or interrnal signal is defined by the <a class="el" href="struct_a_d_c_buf___conversion.html" title="An ADCBuf_Conversion data structure is used with ADCBuf_convert(). It indicates which channel to perf...">ADCBuf_Conversion</a> structure in the application code and adcBufCC26xxObjects in the board file. If the sensor controller is using the ADC when the driver requests it at the start of the <a class="el" href="_a_d_c_8h.html#afcac5582b8be42a7740091d150aef05c" title="Function to perform ADC conversion. ">ADC_convert()</a> call, the conversion will fail and return false. The ADC resource may be pre-acquired by calling the control function ADCBufCC26XX_CMD_ACQUIRE_ADC_SEMAPHORE. It will be released again automatically after the next conversion completes.</p>
<p>In both ADCBufCC26XX_SAMPING_MODE_SYNCHRONOUS mode and ADCBufCC26XX_SAMPING_MODE_ASYNCHRONOUS mode, enough sampling time must be provided between conversions that each measurement may be completed before the next trigger arrives.</p>
<dl class="section note"><dt>Note</dt><dd>The ADCBuf driver requires GPTimer0A to function correctly. It will be unavailable for other uses.</dd></dl>
<h1>Supported ADC pins</h1>
<p>Below is a table of the supported ADC IO pins for each package size, for both CC26xx and CC13xx. It maps a DIO to its corresponding driverlib define for the CompBInput that it is hardwired to. This table can be used to create virtual channel entries in the ADCBufCC26XX_adcChannelLut table in the board file.</p>
<table class="doxtable">
<tr>
<th>DIO </th><th>CC26xx 7x7 AUXIO CompBInput </th><th>CC13xx 7x7 AUXIO CompBInput </th><th>CC26xx 5x5 AUXIO CompBInput </th><th>CC13xx 5x5 AUXIO CompBInput </th><th>CC26xx 4x4 AUXIO CompBInput </th><th>CC13xx 4x4 AUXIO CompBInput  </th></tr>
<tr>
<td>0 </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>1 </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>2 </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>3 </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>4 </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>5 </td><td>No </td><td>No </td><td>No </td><td>No </td><td>ADC_COMPB_IN_AUXIO7 </td><td>ADC_COMPB_IN_AUXIO7 </td></tr>
<tr>
<td>6 </td><td>No </td><td>No </td><td>No </td><td>No </td><td>ADC_COMPB_IN_AUXIO6 </td><td>ADC_COMPB_IN_AUXIO6 </td></tr>
<tr>
<td>7 </td><td>No </td><td>No </td><td>ADC_COMPB_IN_AUXIO7 </td><td>ADC_COMPB_IN_AUXIO7 </td><td>ADC_COMPB_IN_AUXIO5 </td><td>ADC_COMPB_IN_AUXIO5 </td></tr>
<tr>
<td>8 </td><td>No </td><td>No </td><td>ADC_COMPB_IN_AUXIO6 </td><td>ADC_COMPB_IN_AUXIO6 </td><td>ADC_COMPB_IN_AUXIO4 </td><td>ADC_COMPB_IN_AUXIO4 </td></tr>
<tr>
<td>9 </td><td>No </td><td>No </td><td>ADC_COMPB_IN_AUXIO5 </td><td>ADC_COMPB_IN_AUXIO5 </td><td>ADC_COMPB_IN_AUXIO3 </td><td>ADC_COMPB_IN_AUXIO3 </td></tr>
<tr>
<td>10 </td><td>No </td><td>No </td><td>ADC_COMPB_IN_AUXIO4 </td><td>ADC_COMPB_IN_AUXIO4 </td><td>No </td><td>No </td></tr>
<tr>
<td>11 </td><td>No </td><td>No </td><td>ADC_COMPB_IN_AUXIO3 </td><td>ADC_COMPB_IN_AUXIO3 </td><td>No </td><td>No </td></tr>
<tr>
<td>12 </td><td>No </td><td>No </td><td>ADC_COMPB_IN_AUXIO2 </td><td>ADC_COMPB_IN_AUXIO2 </td><td>No </td><td>No </td></tr>
<tr>
<td>13 </td><td>No </td><td>No </td><td>ADC_COMPB_IN_AUXIO1 </td><td>ADC_COMPB_IN_AUXIO1 </td><td>No </td><td>No </td></tr>
<tr>
<td>14 </td><td>No </td><td>No </td><td>ADC_COMPB_IN_AUXIO0 </td><td>ADC_COMPB_IN_AUXIO0 </td><td>No </td><td>No </td></tr>
<tr>
<td>15-22 </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>23 </td><td>ADC_COMPB_IN_AUXIO7 </td><td>ADC_COMPB_IN_AUXIO7 </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>24 </td><td>ADC_COMPB_IN_AUXIO6 </td><td>ADC_COMPB_IN_AUXIO6 </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>25 </td><td>ADC_COMPB_IN_AUXIO5 </td><td>ADC_COMPB_IN_AUXIO5 </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>26 </td><td>ADC_COMPB_IN_AUXIO4 </td><td>ADC_COMPB_IN_AUXIO4 </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>27 </td><td>ADC_COMPB_IN_AUXIO3 </td><td>ADC_COMPB_IN_AUXIO3 </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>28 </td><td>ADC_COMPB_IN_AUXIO2 </td><td>ADC_COMPB_IN_AUXIO2 </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>29 </td><td>ADC_COMPB_IN_AUXIO1 </td><td>ADC_COMPB_IN_AUXIO1 </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
<tr>
<td>30 </td><td>ADC_COMPB_IN_AUXIO0 </td><td>ADC_COMPB_IN_AUXIO0 </td><td>No </td><td>No </td><td>No </td><td>No </td></tr>
</table>
<h1>Supported Internal Signals</h1>
<p>Below is a table of internal signals that can be measured using the ADC. Since we are not connecting to a DIO, there is no DIO to internal signal mapping. The DIO field in the channel lookup table should be marked PIN_UNASSIGNED. This table can be used to create virtual channel entries in the ADCBufCC26XX_adcChannelLut table in the board file.</p>
<table class="doxtable">
<tr>
<th>DIO </th><th>Internal Signal CompBInput  </th></tr>
<tr>
<td>PIN_UNASSIGNED </td><td>ADC_COMPB_IN_DCOUPL </td></tr>
<tr>
<td>PIN_UNASSIGNED </td><td>ADC_COMPB_IN_VSS </td></tr>
<tr>
<td>PIN_UNASSIGNED </td><td>ADC_COMPB_IN_VDDS </td></tr>
</table>
<h1>Error handling</h1>
<p>The following errors may occur when opening the ADC without assertions enabled:</p><ul>
<li>The ADC handle is already open.</li>
</ul>
<p>The following errors may occur when requesting an ADC conversion:</p><ul>
<li>The ADC is currently already doing a conversion.</li>
<li>The ADC was not available (used by sensor controller or basic ADC).</li>
</ul>
<h1>Power Management</h1>
<p>The TI-RTOS power management framework will try to put the device into the most power efficient mode whenever possible. Please see the technical reference manual for further details on each power mode.</p>
<p>While converting, the ADCBufCC26XX driver sets a power constraint to keep the device out of standby. When the conversion has finished, the power constraint is released. The driver also sets a dependency on the DMA to enable background transfers from the ADC FIFO to memory and to clear the GPTimer interrupt. The following statements are valid:</p><ul>
<li>After <a class="el" href="_a_d_c_buf_8h.html#a762253a94875258c5a71b591f03f9d97" title="This function starts a set of conversions on one or more channels. ">ADCBuf_convert()</a>: the device cannot enter standby.</li>
<li>After <a class="el" href="_a_d_c_buf_8h.html#a5201c27bddf11b9f9ae902807bded40d" title="This function cancels an ADC conversion that is in progress. ">ADCBuf_convertCancel()</a>: the device can enter standby again.</li>
<li>After a conversion finishes: the device can enter standby again.</li>
</ul>
<h1>Supported Functions</h1>
<table class="doxtable">
<tr>
<th>API function </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a88a0ab421304465b22417a7adef6c0c2" title="This function initializes the ADC module. This function must. ">ADCBuf_init()</a> </td><td>Initialize ADC driver </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a0b63bca2e8f8e5b58f0c657ac662c97b" title="This function opens a given ADCBuf peripheral. ">ADCBuf_open()</a> </td><td>Open the ADC driver and configure driver </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a762253a94875258c5a71b591f03f9d97" title="This function starts a set of conversions on one or more channels. ">ADCBuf_convert()</a> </td><td>Perform ADC conversion </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a5201c27bddf11b9f9ae902807bded40d" title="This function cancels an ADC conversion that is in progress. ">ADCBuf_convertCancel()</a> </td><td>Cancel ongoing ADC conversion </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a04ab5fae5da8f9ff77ab3ae4974d8f7d" title="Function to close an ADC peripheral specified by the ADC handle. ">ADCBuf_close()</a> </td><td>Close ADC driver </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#ae6ddd34c34fd06cdede98fb01033cc47" title="This function sets all fields of a specified ADCBuf_Params structure to their default values...">ADCBuf_Params_init()</a> </td><td>Initialise <a class="el" href="struct_a_d_c_buf___params.html" title="ADC Parameters. ">ADCBuf_Params</a> structure to default values </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a2ff6d7db155bcd1367ef82a9f5cef19c" title="This function returns the resolution in bits of the specified ADC. ">ADCBuf_getResolution()</a> </td><td>Get the resolution of the ADC of the current device </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a6967c459b64a71b344bd88eb7fbaa097" title="This function adjusts a raw ADC output buffer such that the result is comparable between devices of t...">ADCBuf_adjustRawValues()</a> </td><td>Adjust the values in a returned buffer for manufacturing tolerances </td></tr>
<tr>
<td>ADCBuf_convertAdjustedToMicroVolts </td><td>Convert a buffer of adjusted values to microvolts </td></tr>
<tr>
<td><a class="el" href="_a_d_c_buf_8h.html#a9b9765fb0ac57dee9df234a79dcd5aea" title="Function performs implementation specific features on a given ADCBuf_Handle. ">ADCBuf_control()</a> </td><td>Execute device specific functions </td></tr>
</table>
<h1>Not Supported Functionality</h1>
<p>TBD</p>
<h1>Use Cases</h1>
<h2>Basic one-shot conversion</h2>
<p>Perform one conversion on Board_ADCCHANNEL_A1 in <a class="el" href="_a_d_c_buf_8h.html#a3d643e8024503c5ef2679c83419ba6eea5c6236b2f629b196d7874175be679399">ADCBuf_RETURN_MODE_BLOCKING</a>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_d_c_buf_8h.html">ti/drivers/ADCBuf.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define ADCBUFFERSIZE      100</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="struct_a_d_c_buf___config.html">ADCBuf_Handle</a> adcBufHandle;</div>
<div class="line"><a class="code" href="struct_a_d_c_buf___params.html">ADCBuf_Params</a> adcBufParams;</div>
<div class="line"><a class="code" href="struct_a_d_c_buf___conversion.html">ADCBuf_Conversion</a> blockingConversion;</div>
<div class="line">uint16_t sampleBufferOne[ADCBUFFERSIZE];</div>
<div class="line"></div>
<div class="line"><a class="code" href="_a_d_c_buf_8h.html#ae6ddd34c34fd06cdede98fb01033cc47">ADCBuf_Params_init</a>(&amp;adcBufParams);</div>
<div class="line">adcBufHandle = <a class="code" href="_a_d_c_buf_8h.html#a0b63bca2e8f8e5b58f0c657ac662c97b">ADCBuf_open</a>(Board_ADCBuf0, &amp;adcBufParams);</div>
<div class="line"></div>
<div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#a47080bd2e4d552858be60f6e25be58dc">arg</a> = NULL;</div>
<div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#a379de126469bdd35de64c36498fafb51">adcChannel</a> = Board_ADCCHANNEL_A1;</div>
<div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#a5415e58a69e40124f66cdcc52a097c4a">sampleBuffer</a> = sampleBufferOne;</div>
<div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#a6953e200ba2e5a85b9197bdaeb101a5f">sampleBufferTwo</a> = NULL;</div>
<div class="line">blockingConversion.<a class="code" href="struct_a_d_c_buf___conversion.html#afd95c203d1e7dd347102eef22dc9cc93">samplesRequestedCount</a> = ADCBUFFERSIZE;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (adcBufHandle) {</div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="_a_d_c_buf_8h.html#a762253a94875258c5a71b591f03f9d97">ADCBuf_convert</a>(adcBuf, &amp;blockingConversion, 1)) {</div>
<div class="line">        <span class="comment">// handle error</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        <a class="code" href="_a_d_c_buf_8h.html#a04ab5fae5da8f9ff77ab3ae4974d8f7d">ADCBuf_close</a>(adcBufHandle);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// handle error</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1>Instrumentation</h1>
<p>The ADC driver interface produces log statements if instrumentation is enabled.</p>
<table class="doxtable">
<tr>
<th>Diagnostics Mask </th><th>Log details  </th></tr>
<tr>
<td>Diags_USER1 </td><td>basic ADCBuf operations performed </td></tr>
<tr>
<td>Diags_USER2 </td><td>detailed ADCBuf operations performed </td></tr>
</table>
<hr/>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;<a class="el" href="_a_d_c_buf_8h_source.html">ti/drivers/ADCBuf.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_p_i_n_8h_source.html">ti/drivers/PIN.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_p_i_n_c_c26_x_x_8h_source.html">ti/drivers/pin/PINCC26XX.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_u_d_m_a_c_c26_x_x_8h_source.html">ti/drivers/dma/UDMACC26XX.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_g_p_timer_c_c26_x_x_8h_source.html">ti/drivers/timer/GPTimerCC26XX.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_power_8h_source.html">ti/drivers/Power.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_power_c_c26_x_x_8h_source.html">ti/drivers/power/PowerCC26XX.h</a>&gt;</code><br />
<code>#include &lt;driverlib/aux_adc.h&gt;</code><br />
<code>#include &lt;ti/sysbios/family/arm/m3/Hwi.h&gt;</code><br />
<code>#include &lt;ti/sysbios/knl/Clock.h&gt;</code><br />
<code>#include &lt;ti/sysbios/knl/Semaphore.h&gt;</code><br />
<code>#include &lt;ti/sysbios/knl/Swi.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ADCBufCC26XX.h:</div>
<div class="dyncontent">
<div class="center"><img src="_a_d_c_buf_c_c26_x_x_8h__incl.png" border="0" usemap="#_a_d_c_buf_c_c26_x_x_8h" alt=""/></div>
<map name="_a_d_c_buf_c_c26_x_x_8h" id="_a_d_c_buf_c_c26_x_x_8h">
<area shape="rect" href="_a_d_c_buf_8h.html" title="ADCBuf driver interface. " alt="" coords="392,353,525,377" /><area shape="rect" href="_p_i_n_8h.html" title="Generic PIN &amp; GPIO driver. " alt="" coords="757,353,866,377" /><area shape="rect" href="_p_i_n_c_c26_x_x_8h.html" title="Device&#45;specific pin &amp; GPIO driver for CC26xx family [def]. " alt="" coords="637,265,818,289" /><area shape="rect" href="_u_d_m_a_c_c26_x_x_8h.html" title="UDMACC26XX driver implementation. " alt="" coords="688,109,893,133" /><area shape="rect" href="_power_8h.html" title="Power manager interface. " alt="" coords="490,265,613,289" /><area shape="rect" href="_power_c_c26_x_x_8h.html" title="Power manager interface for CC26XX. " alt="" coords="920,184,1136,208" /><area shape="rect" href="_g_p_timer_c_c26_x_x_8h.html" title="GPTimer driver implementation for CC26XX/CC13XX. " alt="" coords="1312,257,1474,297" /><area shape="rect" href="_list_8h.html" title="Linked List interface for use in drivers. " alt="" coords="549,353,682,377" /></map>
</div>
</div>
<p><a href="_a_d_c_buf_c_c26_x_x_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c_buf_c_c26_x_x___adc_channel_lut_entry.html">ADCBufCC26XX_AdcChannelLutEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table entry that maps a virtual adc channel to a dio and its corresponding internal analogue signal.  <a href="struct_a_d_c_buf_c_c26_x_x___adc_channel_lut_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html">ADCBufCC26XX_ParamsExtension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CC26XX specfic extension to <a class="el" href="struct_a_d_c_buf___params.html" title="ADC Parameters. ">ADCBuf_Params</a>.  <a href="struct_a_d_c_buf_c_c26_x_x___params_extension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c_buf_c_c26_x_x___h_w_attrs.html">ADCBufCC26XX_HWAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADCBufCC26XX Hardware Attributes.  <a href="struct_a_d_c_buf_c_c26_x_x___h_w_attrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_c_buf_c_c26_x_x___object.html">ADCBufCC26XX_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADCBufCC26XX Object.  <a href="struct_a_d_c_buf_c_c26_x_x___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aaa17ecf48f5762e2e1bdb0bab8aacf0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#aaa17ecf48f5762e2e1bdb0bab8aacf0c">ti_sysbios_family_arm_m3_Hwi__nolocalnames</a></td></tr>
<tr class="separator:aaa17ecf48f5762e2e1bdb0bab8aacf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a536e47b039d0f506a4245079af247e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c_buf___c_m_d.html#ga0a536e47b039d0f506a4245079af247e">ADCBufCC26XX_CMD_ACQUIRE_ADC_SEMAPHORE</a>&#160;&#160;&#160;<a class="el" href="_a_d_c_buf_8h.html#a6d889e191027535ad318be0b9c3765d1">ADCBuf_CMD_RESERVED</a> + 1</td></tr>
<tr class="memdesc:ga0a536e47b039d0f506a4245079af247e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This control function acquires the semaphore that arbitrates access to the ADC between the CM3 and the sensor controller.  <a href="group___a_d_c_buf___c_m_d.html#ga0a536e47b039d0f506a4245079af247e">More...</a><br /></td></tr>
<tr class="separator:ga0a536e47b039d0f506a4245079af247e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830dac4199ded43c278e48bb1fe9725e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c_buf___c_m_d.html#ga830dac4199ded43c278e48bb1fe9725e">ADCBufCC26XX_CMD_KEEP_ADC_SEMAPHORE</a>&#160;&#160;&#160;<a class="el" href="_a_d_c_buf_8h.html#a6d889e191027535ad318be0b9c3765d1">ADCBuf_CMD_RESERVED</a> + 2</td></tr>
<tr class="memdesc:ga830dac4199ded43c278e48bb1fe9725e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function makes the ADC driver keep the ADC semaphore until released.  <a href="group___a_d_c_buf___c_m_d.html#ga830dac4199ded43c278e48bb1fe9725e">More...</a><br /></td></tr>
<tr class="separator:ga830dac4199ded43c278e48bb1fe9725e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23015764922f21c49518aa1050d70c0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c_buf___c_m_d.html#ga23015764922f21c49518aa1050d70c0e">ADCBufCC26XX_CMD_KEEP_ADC_SEMAPHORE_DISABLE</a>&#160;&#160;&#160;<a class="el" href="_a_d_c_buf_8h.html#a6d889e191027535ad318be0b9c3765d1">ADCBuf_CMD_RESERVED</a> + 3</td></tr>
<tr class="memdesc:ga23015764922f21c49518aa1050d70c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function makes the ADC driver no longer keep the ADC semaphore until released.  <a href="group___a_d_c_buf___c_m_d.html#ga23015764922f21c49518aa1050d70c0e">More...</a><br /></td></tr>
<tr class="separator:ga23015764922f21c49518aa1050d70c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacc1d31de8c38e71c351bc1fcd54340"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c_buf___c_m_d.html#gaaacc1d31de8c38e71c351bc1fcd54340">ADCBufCC26XX_CMD_RELEASE_ADC_SEMAPHORE</a>&#160;&#160;&#160;<a class="el" href="_a_d_c_buf_8h.html#a6d889e191027535ad318be0b9c3765d1">ADCBuf_CMD_RESERVED</a> + 4</td></tr>
<tr class="memdesc:gaaacc1d31de8c38e71c351bc1fcd54340"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function releases the ADC semaphore.  <a href="group___a_d_c_buf___c_m_d.html#gaaacc1d31de8c38e71c351bc1fcd54340">More...</a><br /></td></tr>
<tr class="separator:gaaacc1d31de8c38e71c351bc1fcd54340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909590e3cb53a9e496ee7d706edad6cd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a909590e3cb53a9e496ee7d706edad6cd">ADCBufCC26XX_RESOLUTION</a>&#160;&#160;&#160;12</td></tr>
<tr class="memdesc:a909590e3cb53a9e496ee7d706edad6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolution in bits of the CC26XX ADC.  <a href="#a909590e3cb53a9e496ee7d706edad6cd">More...</a><br /></td></tr>
<tr class="separator:a909590e3cb53a9e496ee7d706edad6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7445395fba5609c1fccae4b67c72f0cd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a7445395fba5609c1fccae4b67c72f0cd">ADCBufCC26XX_BYTES_PER_SAMPLE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a7445395fba5609c1fccae4b67c72f0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a49a153bb66450bc16c5e2ac674fad698"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a816f299f98f8fc3cc1124cda74a18d10">ADCBufCC26XX_Sampling_Mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a49a153bb66450bc16c5e2ac674fad698">ADCBufCC26XX_Sampling_Mode</a></td></tr>
<tr class="memdesc:a49a153bb66450bc16c5e2ac674fad698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the internal reference of the ADC is sourced from the battery voltage or a fixed internal source.  <a href="#a49a153bb66450bc16c5e2ac674fad698">More...</a><br /></td></tr>
<tr class="separator:a49a153bb66450bc16c5e2ac674fad698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccab39075ab39a107100cfbbc473c47"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fb">ADCBufCC26XX_Sampling_Duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#aeccab39075ab39a107100cfbbc473c47">ADCBufCC26XX_Sampling_Duration</a></td></tr>
<tr class="memdesc:aeccab39075ab39a107100cfbbc473c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of time the ADC spends sampling the analogue input.  <a href="#aeccab39075ab39a107100cfbbc473c47">More...</a><br /></td></tr>
<tr class="separator:aeccab39075ab39a107100cfbbc473c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55267edc4a4440dd55b97f3384474f80"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a31a41d718712f3d4ff936bb566da0d0a">ADCBufCC26XX_Reference_Source</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a55267edc4a4440dd55b97f3384474f80">ADCBufCC26XX_Reference_Source</a></td></tr>
<tr class="memdesc:a55267edc4a4440dd55b97f3384474f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the internal reference of the ADC is sourced from the battery voltage or a fixed internal source.  <a href="#a55267edc4a4440dd55b97f3384474f80">More...</a><br /></td></tr>
<tr class="separator:a55267edc4a4440dd55b97f3384474f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e197fd4f1d0021a0737f74f80d2643"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_a_d_c_buf_c_c26_x_x___adc_channel_lut_entry.html">ADCBufCC26XX_AdcChannelLutEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a99e197fd4f1d0021a0737f74f80d2643">ADCBufCC26XX_AdcChannelLutEntry</a></td></tr>
<tr class="memdesc:a99e197fd4f1d0021a0737f74f80d2643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table entry that maps a virtual adc channel to a dio and its corresponding internal analogue signal.  <a href="#a99e197fd4f1d0021a0737f74f80d2643">More...</a><br /></td></tr>
<tr class="separator:a99e197fd4f1d0021a0737f74f80d2643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac55b5d59cd880fecafb9a71f73162b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html">ADCBufCC26XX_ParamsExtension</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#afac55b5d59cd880fecafb9a71f73162b">ADCBufCC26XX_ParamsExtension</a></td></tr>
<tr class="memdesc:afac55b5d59cd880fecafb9a71f73162b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CC26XX specfic extension to <a class="el" href="struct_a_d_c_buf___params.html" title="ADC Parameters. ">ADCBuf_Params</a>.  <a href="#afac55b5d59cd880fecafb9a71f73162b">More...</a><br /></td></tr>
<tr class="separator:afac55b5d59cd880fecafb9a71f73162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b04734af9e7cbaa1915f92942918fc"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_a_d_c_buf_c_c26_x_x___h_w_attrs.html">ADCBufCC26XX_HWAttrs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a22b04734af9e7cbaa1915f92942918fc">ADCBufCC26XX_HWAttrs</a></td></tr>
<tr class="memdesc:a22b04734af9e7cbaa1915f92942918fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADCBufCC26XX Hardware Attributes.  <a href="#a22b04734af9e7cbaa1915f92942918fc">More...</a><br /></td></tr>
<tr class="separator:a22b04734af9e7cbaa1915f92942918fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7963f859847ffe0853c06219b63ceb42"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_a_d_c_buf_c_c26_x_x___object.html">ADCBufCC26XX_Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a7963f859847ffe0853c06219b63ceb42">ADCBufCC26XX_Object</a></td></tr>
<tr class="memdesc:a7963f859847ffe0853c06219b63ceb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADCBufCC26XX Object.  <a href="#a7963f859847ffe0853c06219b63ceb42">More...</a><br /></td></tr>
<tr class="separator:a7963f859847ffe0853c06219b63ceb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd07a1b826d70701a49d7d951152504"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_a_d_c_buf_c_c26_x_x___object.html">ADCBufCC26XX_Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a1bd07a1b826d70701a49d7d951152504">ADCBufCC26XX_Handle</a></td></tr>
<tr class="separator:a1bd07a1b826d70701a49d7d951152504"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a816f299f98f8fc3cc1124cda74a18d10"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a816f299f98f8fc3cc1124cda74a18d10">ADCBufCC26XX_Sampling_Mode</a> { <br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a816f299f98f8fc3cc1124cda74a18d10a946b45558c94c6f3ade872941a9a3e8a">ADCBufCC26XX_SAMPING_MODE_SYNCHRONOUS</a>, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a816f299f98f8fc3cc1124cda74a18d10a528cdd3ff0e276e7fc85cc6b116af432">ADCBufCC26XX_SAMPING_MODE_ASYNCHRONOUS</a>
<br />
 }</td></tr>
<tr class="memdesc:a816f299f98f8fc3cc1124cda74a18d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the internal reference of the ADC is sourced from the battery voltage or a fixed internal source.  <a href="_a_d_c_buf_c_c26_x_x_8h.html#a816f299f98f8fc3cc1124cda74a18d10">More...</a><br /></td></tr>
<tr class="separator:a816f299f98f8fc3cc1124cda74a18d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a95bf383dea0206b6708496a034a9fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fb">ADCBufCC26XX_Sampling_Duration</a> { <br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fbacd4d4af4fd7304ce2184fa9a22600a22">ADCBufCC26XX_SAMPLING_DURATION_2P7_US</a> = AUXADC_SAMPLE_TIME_2P7_US, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fba4164b576bef7b70e1a3f69eec57a6f62">ADCBufCC26XX_SAMPLING_DURATION_5P3_US</a> = AUXADC_SAMPLE_TIME_5P3_US, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fba49ca33f11fcff33041eb0cbc19a089b4">ADCBufCC26XX_SAMPLING_DURATION_10P6_US</a> = AUXADC_SAMPLE_TIME_10P6_US, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fba0156bc1aa641d10df8a820395f7193bf">ADCBufCC26XX_SAMPLING_DURATION_21P3_US</a> = AUXADC_SAMPLE_TIME_21P3_US, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fba150c59385da570a79aea1e4c0c1e914b">ADCBufCC26XX_SAMPLING_DURATION_42P6_US</a> = AUXADC_SAMPLE_TIME_42P6_US, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fba921a55551370c46180f3ab729a4da912">ADCBufCC26XX_SAMPLING_DURATION_85P3_US</a> = AUXADC_SAMPLE_TIME_85P3_US, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fbad1d82e9bb12e373860ad36ba6cee7a9f">ADCBufCC26XX_SAMPLING_DURATION_170_US</a> = AUXADC_SAMPLE_TIME_170_US, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fba5d7638fadf06f706a13588e0c8957b27">ADCBufCC26XX_SAMPLING_DURATION_341_US</a> = AUXADC_SAMPLE_TIME_341_US, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fba41124a9e4bc93d0ebbc01b78bc3e9a7e">ADCBufCC26XX_SAMPLING_DURATION_682_US</a> = AUXADC_SAMPLE_TIME_682_US, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fbacb02ad19af7a0912549716115af13f88">ADCBufCC26XX_SAMPLING_DURATION_1P37_MS</a> = AUXADC_SAMPLE_TIME_1P37_MS, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fbab73858ae3ffa520756cdfca77df35602">ADCBufCC26XX_SAMPLING_DURATION_2P73_MS</a> = AUXADC_SAMPLE_TIME_2P73_MS, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fba4dea9b186e256b8cfb71722ae689889d">ADCBufCC26XX_SAMPLING_DURATION_5P46_MS</a> = AUXADC_SAMPLE_TIME_5P46_MS, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fbaf5746a2bb589e0fc237dfe7cea002859">ADCBufCC26XX_SAMPLING_DURATION_10P9_MS</a> = AUXADC_SAMPLE_TIME_10P9_MS
<br />
 }</td></tr>
<tr class="memdesc:a4a95bf383dea0206b6708496a034a9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of time the ADC spends sampling the analogue input.  <a href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fb">More...</a><br /></td></tr>
<tr class="separator:a4a95bf383dea0206b6708496a034a9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a41d718712f3d4ff936bb566da0d0a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a31a41d718712f3d4ff936bb566da0d0a">ADCBufCC26XX_Reference_Source</a> { <br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a31a41d718712f3d4ff936bb566da0d0aad02c445be8959c127744cfe9519d1770">ADCBufCC26XX_FIXED_REFERENCE</a> = AUXADC_REF_FIXED, 
<br />
&#160;&#160;<a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a31a41d718712f3d4ff936bb566da0d0aa4b0c0d3239bf0e32219c87df11baa0c9">ADCBufCC26XX_VDDS_REFERENCE</a> = AUXADC_REF_VDDS_REL
<br />
 }</td></tr>
<tr class="memdesc:a31a41d718712f3d4ff936bb566da0d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the internal reference of the ADC is sourced from the battery voltage or a fixed internal source.  <a href="_a_d_c_buf_c_c26_x_x_8h.html#a31a41d718712f3d4ff936bb566da0d0a">More...</a><br /></td></tr>
<tr class="separator:a31a41d718712f3d4ff936bb566da0d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab26fa75463dae8b7a8c9d7585735177a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_a_d_c_buf___fxn_table.html">ADCBuf_FxnTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#ab26fa75463dae8b7a8c9d7585735177a">ADCBufCC26XX_fxnTable</a></td></tr>
<tr class="separator:ab26fa75463dae8b7a8c9d7585735177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="aaa17ecf48f5762e2e1bdb0bab8aacf0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ti_sysbios_family_arm_m3_Hwi__nolocalnames</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a909590e3cb53a9e496ee7d706edad6cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADCBufCC26XX_RESOLUTION&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolution in bits of the CC26XX ADC. </p>

</div>
</div>
<a class="anchor" id="a7445395fba5609c1fccae4b67c72f0cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADCBufCC26XX_BYTES_PER_SAMPLE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a49a153bb66450bc16c5e2ac674fad698"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a816f299f98f8fc3cc1124cda74a18d10">ADCBufCC26XX_Sampling_Mode</a>  <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a816f299f98f8fc3cc1124cda74a18d10">ADCBufCC26XX_Sampling_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether the internal reference of the ADC is sourced from the battery voltage or a fixed internal source. </p>
<p>The CC26XX ADC can operate in two different ways with regards to the sampling phase of the ADC conversion process:</p><ul>
<li>It can spend a fixed amount of time sampling the signal after getting the start conversion trigger.</li>
<li>It can constantly keep sampling and immediately start the conversion process after getting the trigger.</li>
</ul>
<p>In ADCBufCC26XX_SYNCHRONOUS mode, the ADC goes into IDLE in between conversions and uses less power. The minimum sample time for full precision in ADCBufCC26XX_SAMPING_MODE_SYNCHRONOUS is dependent on the input load. </p>

</div>
</div>
<a class="anchor" id="aeccab39075ab39a107100cfbbc473c47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fb">ADCBufCC26XX_Sampling_Duration</a>  <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fb">ADCBufCC26XX_Sampling_Duration</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Amount of time the ADC spends sampling the analogue input. </p>
<p>The analogue to digital conversion process consists of two phases in the CC26XX ADC, the sampling and conversion phases. During the sampling phase, the ADC samples the analogue input signal. Larger input loads require longer sample times for the most accurate results. In ADCBufCC26XX_SAMPING_MODE_SYNCHRONOUS mode, this enum specifies the sampling times available. </p>

</div>
</div>
<a class="anchor" id="a55267edc4a4440dd55b97f3384474f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a31a41d718712f3d4ff936bb566da0d0a">ADCBufCC26XX_Reference_Source</a>  <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a31a41d718712f3d4ff936bb566da0d0a">ADCBufCC26XX_Reference_Source</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether the internal reference of the ADC is sourced from the battery voltage or a fixed internal source. </p>
<ul>
<li>In practice, using the internal fixed voltage reference sets the upper range of the ADC to a fixed value. That value is 4.3V with input scaling enabled and ~1.4785V with input scaling disabled. In this mode, the output is a function of the input voltage multiplied by the resolution in alternatives (not bits) divided by the upper voltage range of the ADC. Output = Input (V) * 2^12 / (ADC range (V))</li>
<li>Using VDDS as a reference scales the upper range of the ADC with the battery voltage. As the battery depletes and its voltage drops, so does the range of the ADC. This is helpful when measuring signals that are generated relative to the battery voltage. In this mode, the output is a function of the input voltage multiplied by the resolution in alternatives (not bits) divided by VDDS multiplied by a scaling factor derived from the input scaling. Output = Input (V) * 2^12 / (VDDS (V) * Scaling factor), where the scaling factor is ~1.4785/4.3 for input scaling disabled and 1 for input scaling enabled.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The actual reference values are slightly different for each device and are higher than the values specified above. This gain is saved in the FCFG. The function ADCBuf_convertRawToMicroVolts() must be used to derive actual voltage values. Do not attempt to compare raw values between devices or derive a voltage from them yourself. The results of doing so will only be approximately correct.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Even though the upper voltage range of the ADC is 4.3 volts in fixed mode with input scaling enabled, the input should never exceed VDDS as per the data sheet. </dd></dl>

</div>
</div>
<a class="anchor" id="a99e197fd4f1d0021a0737f74f80d2643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_a_d_c_buf_c_c26_x_x___adc_channel_lut_entry.html">ADCBufCC26XX_AdcChannelLutEntry</a>  <a class="el" href="struct_a_d_c_buf_c_c26_x_x___adc_channel_lut_entry.html">ADCBufCC26XX_AdcChannelLutEntry</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Table entry that maps a virtual adc channel to a dio and its corresponding internal analogue signal. </p>
<p>Non-dio signals can be used as well. To do this, compBInput is set to the driverlib define corresponding to the desired non-dio signal and dio is set to PIN_UNASSIGNED. </p>

</div>
</div>
<a class="anchor" id="afac55b5d59cd880fecafb9a71f73162b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html">ADCBufCC26XX_ParamsExtension</a>  <a class="el" href="struct_a_d_c_buf_c_c26_x_x___params_extension.html">ADCBufCC26XX_ParamsExtension</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CC26XX specfic extension to <a class="el" href="struct_a_d_c_buf___params.html" title="ADC Parameters. ">ADCBuf_Params</a>. </p>
<p>To use non-default CC26XX specific parameters when calling <a class="el" href="_a_d_c_buf_8h.html#a0b63bca2e8f8e5b58f0c657ac662c97b" title="This function opens a given ADCBuf peripheral. ">ADCBuf_open()</a>, a pointer to an instance of this struct must be specified in <a class="el" href="struct_a_d_c_buf___params.html#a72c7ec51318ec2f8fcf5d2ff37de33e3">ADCBuf_Params::custom</a>. Alternatively, these values can be set using the control function after calling <a class="el" href="_a_d_c_buf_8h.html#a0b63bca2e8f8e5b58f0c657ac662c97b" title="This function opens a given ADCBuf peripheral. ">ADCBuf_open()</a>. </p>

</div>
</div>
<a class="anchor" id="a22b04734af9e7cbaa1915f92942918fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_a_d_c_buf_c_c26_x_x___h_w_attrs.html">ADCBufCC26XX_HWAttrs</a>  <a class="el" href="struct_a_d_c_buf_c_c26_x_x___h_w_attrs.html">ADCBufCC26XX_HWAttrs</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADCBufCC26XX Hardware Attributes. </p>
<p>These fields are used by driverlib APIs and therefore must be populated by driverlib macro definitions. For CC26xxWare these definitions are found in:</p><ul>
<li>inc/hw_memmap.h</li>
<li>inc/hw_ints.h</li>
</ul>
<p>A sample structure is shown below: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;const ADCBufCC26XX_HWAttrs ADCBufCC26XXHWAttrs[] = {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        .intPriority = ~0,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        .swiPriority = 0,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        .gpTimerUnit = CC2650_GPTIMER0A,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        .gptDMAChannelMask = 1 &lt;&lt; UDMA_CHAN_TIMER0_A,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    }</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;};</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7963f859847ffe0853c06219b63ceb42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_a_d_c_buf_c_c26_x_x___object.html">ADCBufCC26XX_Object</a>  <a class="el" href="struct_a_d_c_buf_c_c26_x_x___object.html">ADCBufCC26XX_Object</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ADCBufCC26XX Object. </p>
<p>The application must not access any member variables of this structure! </p>

</div>
</div>
<a class="anchor" id="a1bd07a1b826d70701a49d7d951152504"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_a_d_c_buf_c_c26_x_x___object.html">ADCBufCC26XX_Object</a> * <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a1bd07a1b826d70701a49d7d951152504">ADCBufCC26XX_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a816f299f98f8fc3cc1124cda74a18d10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a816f299f98f8fc3cc1124cda74a18d10">ADCBufCC26XX_Sampling_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether the internal reference of the ADC is sourced from the battery voltage or a fixed internal source. </p>
<p>The CC26XX ADC can operate in two different ways with regards to the sampling phase of the ADC conversion process:</p><ul>
<li>It can spend a fixed amount of time sampling the signal after getting the start conversion trigger.</li>
<li>It can constantly keep sampling and immediately start the conversion process after getting the trigger.</li>
</ul>
<p>In ADCBufCC26XX_SYNCHRONOUS mode, the ADC goes into IDLE in between conversions and uses less power. The minimum sample time for full precision in ADCBufCC26XX_SAMPING_MODE_SYNCHRONOUS is dependent on the input load. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a816f299f98f8fc3cc1124cda74a18d10a946b45558c94c6f3ade872941a9a3e8a"></a>ADCBufCC26XX_SAMPING_MODE_SYNCHRONOUS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a816f299f98f8fc3cc1124cda74a18d10a528cdd3ff0e276e7fc85cc6b116af432"></a>ADCBufCC26XX_SAMPING_MODE_ASYNCHRONOUS&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a4a95bf383dea0206b6708496a034a9fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a4a95bf383dea0206b6708496a034a9fb">ADCBufCC26XX_Sampling_Duration</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Amount of time the ADC spends sampling the analogue input. </p>
<p>The analogue to digital conversion process consists of two phases in the CC26XX ADC, the sampling and conversion phases. During the sampling phase, the ADC samples the analogue input signal. Larger input loads require longer sample times for the most accurate results. In ADCBufCC26XX_SAMPING_MODE_SYNCHRONOUS mode, this enum specifies the sampling times available. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fbacd4d4af4fd7304ce2184fa9a22600a22"></a>ADCBufCC26XX_SAMPLING_DURATION_2P7_US&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fba4164b576bef7b70e1a3f69eec57a6f62"></a>ADCBufCC26XX_SAMPLING_DURATION_5P3_US&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fba49ca33f11fcff33041eb0cbc19a089b4"></a>ADCBufCC26XX_SAMPLING_DURATION_10P6_US&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fba0156bc1aa641d10df8a820395f7193bf"></a>ADCBufCC26XX_SAMPLING_DURATION_21P3_US&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fba150c59385da570a79aea1e4c0c1e914b"></a>ADCBufCC26XX_SAMPLING_DURATION_42P6_US&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fba921a55551370c46180f3ab729a4da912"></a>ADCBufCC26XX_SAMPLING_DURATION_85P3_US&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fbad1d82e9bb12e373860ad36ba6cee7a9f"></a>ADCBufCC26XX_SAMPLING_DURATION_170_US&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fba5d7638fadf06f706a13588e0c8957b27"></a>ADCBufCC26XX_SAMPLING_DURATION_341_US&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fba41124a9e4bc93d0ebbc01b78bc3e9a7e"></a>ADCBufCC26XX_SAMPLING_DURATION_682_US&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fbacb02ad19af7a0912549716115af13f88"></a>ADCBufCC26XX_SAMPLING_DURATION_1P37_MS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fbab73858ae3ffa520756cdfca77df35602"></a>ADCBufCC26XX_SAMPLING_DURATION_2P73_MS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fba4dea9b186e256b8cfb71722ae689889d"></a>ADCBufCC26XX_SAMPLING_DURATION_5P46_MS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4a95bf383dea0206b6708496a034a9fbaf5746a2bb589e0fc237dfe7cea002859"></a>ADCBufCC26XX_SAMPLING_DURATION_10P9_MS&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a31a41d718712f3d4ff936bb566da0d0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_a_d_c_buf_c_c26_x_x_8h.html#a31a41d718712f3d4ff936bb566da0d0a">ADCBufCC26XX_Reference_Source</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether the internal reference of the ADC is sourced from the battery voltage or a fixed internal source. </p>
<ul>
<li>In practice, using the internal fixed voltage reference sets the upper range of the ADC to a fixed value. That value is 4.3V with input scaling enabled and ~1.4785V with input scaling disabled. In this mode, the output is a function of the input voltage multiplied by the resolution in alternatives (not bits) divided by the upper voltage range of the ADC. Output = Input (V) * 2^12 / (ADC range (V))</li>
<li>Using VDDS as a reference scales the upper range of the ADC with the battery voltage. As the battery depletes and its voltage drops, so does the range of the ADC. This is helpful when measuring signals that are generated relative to the battery voltage. In this mode, the output is a function of the input voltage multiplied by the resolution in alternatives (not bits) divided by VDDS multiplied by a scaling factor derived from the input scaling. Output = Input (V) * 2^12 / (VDDS (V) * Scaling factor), where the scaling factor is ~1.4785/4.3 for input scaling disabled and 1 for input scaling enabled.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The actual reference values are slightly different for each device and are higher than the values specified above. This gain is saved in the FCFG. The function ADCBuf_convertRawToMicroVolts() must be used to derive actual voltage values. Do not attempt to compare raw values between devices or derive a voltage from them yourself. The results of doing so will only be approximately correct.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Even though the upper voltage range of the ADC is 4.3 volts in fixed mode with input scaling enabled, the input should never exceed VDDS as per the data sheet. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a31a41d718712f3d4ff936bb566da0d0aad02c445be8959c127744cfe9519d1770"></a>ADCBufCC26XX_FIXED_REFERENCE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a31a41d718712f3d4ff936bb566da0d0aa4b0c0d3239bf0e32219c87df11baa0c9"></a>ADCBufCC26XX_VDDS_REFERENCE&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ab26fa75463dae8b7a8c9d7585735177a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_a_d_c_buf___fxn_table.html">ADCBuf_FxnTable</a> ADCBufCC26XX_fxnTable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
Copyright  2018, Texas Instruments Incorporated
</small>
</body>
</html>
