<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>TI-RTOS Drivers: I2C.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TI-RTOS Drivers
   &#160;<span id="projectnumber">tidrivers_cc13xx_cc26xx_2_21_01_01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c17777783ce38a5c07940aaaf742f522.html">exports</a></li><li class="navelem"><a class="el" href="dir_f6e916242039e0349c75a086e347d29e.html">tidrivers_cc13xx_cc26xx_2_21_01_01</a></li><li class="navelem"><a class="el" href="dir_66ebce97428d8a203c418c1e1c30b1d0.html">packages</a></li><li class="navelem"><a class="el" href="dir_bb9bb6c41181976c26c510dde001be8f.html">ti</a></li><li class="navelem"><a class="el" href="dir_3272f9f9556099c0b986cb38fa788482.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>I2C driver interface. </p>
<p>============================================================================</p>
<p>The I2C header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i2_c_8h.html">ti/drivers/I2C.h</a>&gt;</span></div>
</div><!-- fragment --><h1>Operation</h1>
<p>The I2C driver operates as a master on a single-master I2C bus in either I2C_MODE_BLOCKING or I2C_MODE_CALLBACK. In blocking mode, the task's execution is blocked during the I2C transaction. When the transfer has completed, code execution will resume. In callback mode, the task's execution is not blocked, allowing for other transactions to be queued up or to process some other code. When the transfer has completed, the I2C driver will call a user-specified callback function (from a HWI or SWI context, depending on the device).</p>
<p>The APIs in this driver serve as an interface to a typical TI-RTOS application. The specific peripheral implementations are responsible to create all the SYS/BIOS specific primitives to allow for thread-safe operation.</p>
<h2>Opening the driver</h2>
<div class="fragment"><div class="line"><a class="code" href="struct_i2_c___config.html">I2C_Handle</a>      handle;</div>
<div class="line"><a class="code" href="struct_i2_c___params.html">I2C_Params</a>      params;</div>
<div class="line"><a class="code" href="struct_i2_c___transaction.html">I2C_Transaction</a> i2cTransaction;</div>
<div class="line"></div>
<div class="line"><a class="code" href="_i2_c_8h.html#ab11636302074d67180207ab81ceb323c">I2C_Params_init</a>(&amp;params);</div>
<div class="line">params.<a class="code" href="struct_i2_c___params.html#a79c5c51380ffbdb21df1dff6cb57de0e">transferMode</a>  = <a class="code" href="_i2_c_8h.html#a39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>;</div>
<div class="line">params.<a class="code" href="struct_i2_c___params.html#a57edf1b900368904779d0c57a73cf047">transferCallbackFxn</a> = someI2CCallbackFunction;</div>
<div class="line">handle = <a class="code" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e">I2C_open</a>(someI2C_configIndexValue, &amp;params);</div>
<div class="line"><span class="keywordflow">if</span> (!handle) {</div>
<div class="line">    System_printf(<span class="stringliteral">&quot;I2C did not open&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Transferring data</h2>
<p>A I2C transaction with a I2C peripheral is started by calling <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a>. The details of the I2C transaction is specified with a <a class="el" href="struct_i2_c___transaction.html" title="I2C transaction. ">I2C_Transaction</a> data structure. This structure allows for any of the three types of transactions: Write, Read, or Write/Read. Each transfer is performed atomically with the I2C slave peripheral.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_i2_c___transaction.html">I2C_Transaction</a> i2cTransaction;</div>
<div class="line"></div>
<div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#aa3490c2af4b443a7a4ec13f57aec6d20">writeBuf</a> = someWriteBuffer;</div>
<div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a08959a9f098163d02d6002e73b3a4606">writeCount</a> = numOfBytesToWrite;</div>
<div class="line"></div>
<div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a804b918d5cb08bb75a39866d0b89e01e">readBuf</a> = someReadBuffer;</div>
<div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a2085d4c943f0d8617365b7c427e6a0de">readCount</a> = numOfBytesToRead;</div>
<div class="line"></div>
<div class="line">i2cTransaction.<a class="code" href="struct_i2_c___transaction.html#a165300f1959631edfccd21f0ae052e1b">slaveAddress</a> = some7BitI2CSlaveAddress;</div>
<div class="line"></div>
<div class="line">ret = <a class="code" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a>(handle, &amp;i2cTransaction);</div>
<div class="line"><span class="keywordflow">if</span> (!ret) {</div>
<div class="line">    System_printf(<span class="stringliteral">&quot;Unsuccessful I2C transfer&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h1>Implementation</h1>
<p>This module serves as the main interface for TI-RTOS applications. Its purpose is to redirect the module's APIs to specific peripheral implementations which are specified using a pointer to a <a class="el" href="struct_i2_c___fxn_table.html" title="The definition of an I2C function table that contains the required set of functions to control a spec...">I2C_FxnTable</a>.</p>
<p>The I2C driver interface module is joined (at link time) to a NULL-terminated array of <a class="el" href="struct_i2_c___config.html" title="I2C global configuration. ">I2C_Config</a> data structures named <em>I2C_config</em>. <em>I2C_config</em> is implemented in the application with each entry being an instance of a I2C peripheral. Each entry in <em>I2C_config</em> contains a:</p><ul>
<li>(<a class="el" href="struct_i2_c___fxn_table.html" title="The definition of an I2C function table that contains the required set of functions to control a spec...">I2C_FxnTable</a> *) to a set of functions that implement a I2C peripheral</li>
<li>(void *) data object that is associated with the <a class="el" href="struct_i2_c___fxn_table.html" title="The definition of an I2C function table that contains the required set of functions to control a spec...">I2C_FxnTable</a></li>
<li>(void *) hardware attributes that are associated to the <a class="el" href="struct_i2_c___fxn_table.html" title="The definition of an I2C function table that contains the required set of functions to control a spec...">I2C_FxnTable</a></li>
</ul>
<h1>Instrumentation</h1>
<p>The I2C driver interface produces log statements if instrumentation is enabled.</p>
<table class="doxtable">
<tr>
<th>Diagnostics Mask </th><th>Log details  </th></tr>
<tr>
<td>Diags_USER1 </td><td>basic operations performed </td></tr>
<tr>
<td>Diags_USER2 </td><td>detailed operations performed </td></tr>
</table>
<hr/>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for I2C.h:</div>
<div class="dyncontent">
<div class="center"><img src="_i2_c_8h__incl.png" border="0" usemap="#_i2_c_8h" alt=""/></div>
<map name="_i2_c_8h" id="_i2_c_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_i2_c_8h__dep__incl.png" border="0" usemap="#_i2_c_8hdep" alt=""/></div>
<map name="_i2_c_8hdep" id="_i2_c_8hdep">
<area shape="rect" href="_i2_c_c_c26_x_x_8h.html" title="I2C driver implementation for a CC26XX I2C controller. " alt="" coords="8,83,112,107" /></map>
</div>
</div>
<p><a href="_i2_c_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transaction.  <a href="struct_i2_c___transaction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___params.html">I2C_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Parameters.  <a href="struct_i2_c___params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___fxn_table.html">I2C_FxnTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of an I2C function table that contains the required set of functions to control a specific I2C driver implementation.  <a href="struct_i2_c___fxn_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___config.html">I2C_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C global configuration.  <a href="struct_i2_c___config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga760ec0a6fdb876ccc67b6f06301d53ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___c_o_n_t_r_o_l.html#ga760ec0a6fdb876ccc67b6f06301d53ec">I2C_CMD_RESERVED</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:ga760ec0a6fdb876ccc67b6f06301d53ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfd04572fe349d087c2547501cbc7e0a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___c_o_n_t_r_o_l.html#gacfd04572fe349d087c2547501cbc7e0a">I2C_STATUS_RESERVED</a>&#160;&#160;&#160;-32</td></tr>
<tr class="separator:gacfd04572fe349d087c2547501cbc7e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0bcf3acd26ac82bd8ff91daba2c78c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___s_t_a_t_u_s.html#gaa0bcf3acd26ac82bd8ff91daba2c78c4">I2C_STATUS_SUCCESS</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaa0bcf3acd26ac82bd8ff91daba2c78c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successful status code returned by <a class="el" href="_i2_c_8h.html#a633003582213a5098467a4e647cc52f9" title="Perform implementation specific features on a given I2C_Handle. ">I2C_control()</a>.  <a href="group___i2_c___s_t_a_t_u_s.html#gaa0bcf3acd26ac82bd8ff91daba2c78c4">More...</a><br /></td></tr>
<tr class="separator:gaa0bcf3acd26ac82bd8ff91daba2c78c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7323fe57c39c46d0da9910e17f5f0b06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___s_t_a_t_u_s.html#ga7323fe57c39c46d0da9910e17f5f0b06">I2C_STATUS_ERROR</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:ga7323fe57c39c46d0da9910e17f5f0b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error status code returned by <a class="el" href="_i2_c_8h.html#a633003582213a5098467a4e647cc52f9" title="Perform implementation specific features on a given I2C_Handle. ">I2C_control()</a>.  <a href="group___i2_c___s_t_a_t_u_s.html#ga7323fe57c39c46d0da9910e17f5f0b06">More...</a><br /></td></tr>
<tr class="separator:ga7323fe57c39c46d0da9910e17f5f0b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11c31c9869ed2441789205d9e5967d66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___s_t_a_t_u_s.html#ga11c31c9869ed2441789205d9e5967d66">I2C_STATUS_UNDEFINEDCMD</a>&#160;&#160;&#160;-2</td></tr>
<tr class="memdesc:ga11c31c9869ed2441789205d9e5967d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error status code returned by <a class="el" href="_i2_c_8h.html#a633003582213a5098467a4e647cc52f9" title="Perform implementation specific features on a given I2C_Handle. ">I2C_control()</a> for undefined command codes.  <a href="group___i2_c___s_t_a_t_u_s.html#ga11c31c9869ed2441789205d9e5967d66">More...</a><br /></td></tr>
<tr class="separator:ga11c31c9869ed2441789205d9e5967d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5809a229f8395c87f59e63128195c1bf"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___config.html">I2C_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a></td></tr>
<tr class="memdesc:a5809a229f8395c87f59e63128195c1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from a <a class="el" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e" title="Initialize a given I2C peripheral specified by the particular index value. The parameter specifies wh...">I2C_open()</a> call.  <a href="#a5809a229f8395c87f59e63128195c1bf">More...</a><br /></td></tr>
<tr class="separator:a5809a229f8395c87f59e63128195c1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d2d506a10628451340a2901bdb6277"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a54d2d506a10628451340a2901bdb6277">I2C_Transaction</a></td></tr>
<tr class="memdesc:a54d2d506a10628451340a2901bdb6277"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transaction.  <a href="#a54d2d506a10628451340a2901bdb6277">More...</a><br /></td></tr>
<tr class="separator:a54d2d506a10628451340a2901bdb6277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74176ca6d49d4081eeacb270a8e9c800"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_i2_c_8h.html#a39f3b9340fc4ee241b0d2da9b2841c26">I2C_TransferMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a74176ca6d49d4081eeacb270a8e9c800">I2C_TransferMode</a></td></tr>
<tr class="memdesc:a74176ca6d49d4081eeacb270a8e9c800"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transfer mode.  <a href="#a74176ca6d49d4081eeacb270a8e9c800">More...</a><br /></td></tr>
<tr class="separator:a74176ca6d49d4081eeacb270a8e9c800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7389002843eba77425c73b441358fd1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#aa7389002843eba77425c73b441358fd1">I2C_CallbackFxn</a>) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a>, <a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a> *, bool)</td></tr>
<tr class="memdesc:aa7389002843eba77425c73b441358fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C callback function.  <a href="#aa7389002843eba77425c73b441358fd1">More...</a><br /></td></tr>
<tr class="separator:aa7389002843eba77425c73b441358fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4614c71f39459a9cc729b1f183d795f3"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_i2_c_8h.html#ac954e3197f04c50293db466c4abb6fbe">I2C_BitRate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a4614c71f39459a9cc729b1f183d795f3">I2C_BitRate</a></td></tr>
<tr class="memdesc:a4614c71f39459a9cc729b1f183d795f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C bitRate.  <a href="#a4614c71f39459a9cc729b1f183d795f3">More...</a><br /></td></tr>
<tr class="separator:a4614c71f39459a9cc729b1f183d795f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b2a2e3bc3716b5716ad6c1f10d7c1d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___params.html">I2C_Params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#ae6b2a2e3bc3716b5716ad6c1f10d7c1d">I2C_Params</a></td></tr>
<tr class="memdesc:ae6b2a2e3bc3716b5716ad6c1f10d7c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Parameters.  <a href="#ae6b2a2e3bc3716b5716ad6c1f10d7c1d">More...</a><br /></td></tr>
<tr class="separator:ae6b2a2e3bc3716b5716ad6c1f10d7c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a829a2a0fd594c50e93c3e55c7d04aa"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a7a829a2a0fd594c50e93c3e55c7d04aa">I2C_CancelFxn</a>) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:a7a829a2a0fd594c50e93c3e55c7d04aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a8cad0c04a9eca0fffc0ffe5586a5179b" title="Cancel all I2C transfers. ">I2C_cancel()</a>.  <a href="#a7a829a2a0fd594c50e93c3e55c7d04aa">More...</a><br /></td></tr>
<tr class="separator:a7a829a2a0fd594c50e93c3e55c7d04aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083200108e980a0ef61e458f0b9fb9e7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a083200108e980a0ef61e458f0b9fb9e7">I2C_CloseFxn</a>) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:a083200108e980a0ef61e458f0b9fb9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a12c86d89a687f2ee1eb980d99c32326d" title="Close an I2C peripheral specified by an I2C handle. ">I2C_close()</a>.  <a href="#a083200108e980a0ef61e458f0b9fb9e7">More...</a><br /></td></tr>
<tr class="separator:a083200108e980a0ef61e458f0b9fb9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b15853f98d3d5e5135b8c52b8465fff"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a4b15853f98d3d5e5135b8c52b8465fff">I2C_ControlFxn</a>) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle, unsigned int cmd, void *arg)</td></tr>
<tr class="memdesc:a4b15853f98d3d5e5135b8c52b8465fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a633003582213a5098467a4e647cc52f9" title="Perform implementation specific features on a given I2C_Handle. ">I2C_control()</a>.  <a href="#a4b15853f98d3d5e5135b8c52b8465fff">More...</a><br /></td></tr>
<tr class="separator:a4b15853f98d3d5e5135b8c52b8465fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb2451c8a1ce70402e43e4743c5fedf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#adfb2451c8a1ce70402e43e4743c5fedf">I2C_InitFxn</a>) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:adfb2451c8a1ce70402e43e4743c5fedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a>.  <a href="#adfb2451c8a1ce70402e43e4743c5fedf">More...</a><br /></td></tr>
<tr class="separator:adfb2451c8a1ce70402e43e4743c5fedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add24fcdaaf1bdef1521ce2489bf1d80e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#add24fcdaaf1bdef1521ce2489bf1d80e">I2C_OpenFxn</a>) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle, <a class="el" href="struct_i2_c___params.html">I2C_Params</a> *params)</td></tr>
<tr class="memdesc:add24fcdaaf1bdef1521ce2489bf1d80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e" title="Initialize a given I2C peripheral specified by the particular index value. The parameter specifies wh...">I2C_open()</a>.  <a href="#add24fcdaaf1bdef1521ce2489bf1d80e">More...</a><br /></td></tr>
<tr class="separator:add24fcdaaf1bdef1521ce2489bf1d80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa785484e689c79262f98208689fecd38"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#aa785484e689c79262f98208689fecd38">I2C_TransferFxn</a>) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle, <a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:aa785484e689c79262f98208689fecd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a>.  <a href="#aa785484e689c79262f98208689fecd38">More...</a><br /></td></tr>
<tr class="separator:aa785484e689c79262f98208689fecd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc2b5945fac9724271b088437881d68"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___fxn_table.html">I2C_FxnTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#abdc2b5945fac9724271b088437881d68">I2C_FxnTable</a></td></tr>
<tr class="memdesc:abdc2b5945fac9724271b088437881d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of an I2C function table that contains the required set of functions to control a specific I2C driver implementation.  <a href="#abdc2b5945fac9724271b088437881d68">More...</a><br /></td></tr>
<tr class="separator:abdc2b5945fac9724271b088437881d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06eeddd0e8a5dd24a18566b65099d588"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___config.html">I2C_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a06eeddd0e8a5dd24a18566b65099d588">I2C_Config</a></td></tr>
<tr class="memdesc:a06eeddd0e8a5dd24a18566b65099d588"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C global configuration.  <a href="#a06eeddd0e8a5dd24a18566b65099d588">More...</a><br /></td></tr>
<tr class="separator:a06eeddd0e8a5dd24a18566b65099d588"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a39f3b9340fc4ee241b0d2da9b2841c26"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a39f3b9340fc4ee241b0d2da9b2841c26">I2C_TransferMode</a> { <br />
&#160;&#160;<a class="el" href="_i2_c_8h.html#a39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75">I2C_MODE_BLOCKING</a>, 
<br />
&#160;&#160;<a class="el" href="_i2_c_8h.html#a39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72">I2C_MODE_CALLBACK</a>
<br />
 }</td></tr>
<tr class="memdesc:a39f3b9340fc4ee241b0d2da9b2841c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transfer mode.  <a href="_i2_c_8h.html#a39f3b9340fc4ee241b0d2da9b2841c26">More...</a><br /></td></tr>
<tr class="separator:a39f3b9340fc4ee241b0d2da9b2841c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac954e3197f04c50293db466c4abb6fbe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#ac954e3197f04c50293db466c4abb6fbe">I2C_BitRate</a> { <br />
&#160;&#160;<a class="el" href="_i2_c_8h.html#ac954e3197f04c50293db466c4abb6fbea966fd2df13b3a9825615c50335cf1987">I2C_100kHz</a> = 0, 
<br />
&#160;&#160;<a class="el" href="_i2_c_8h.html#ac954e3197f04c50293db466c4abb6fbea83cc3750242e6ae9194cd7ed94f764d9">I2C_400kHz</a> = 1
<br />
 }</td></tr>
<tr class="memdesc:ac954e3197f04c50293db466c4abb6fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C bitRate.  <a href="_i2_c_8h.html#ac954e3197f04c50293db466c4abb6fbe">More...</a><br /></td></tr>
<tr class="separator:ac954e3197f04c50293db466c4abb6fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8cad0c04a9eca0fffc0ffe5586a5179b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a8cad0c04a9eca0fffc0ffe5586a5179b">I2C_cancel</a> (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:a8cad0c04a9eca0fffc0ffe5586a5179b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all I2C transfers.  <a href="#a8cad0c04a9eca0fffc0ffe5586a5179b">More...</a><br /></td></tr>
<tr class="separator:a8cad0c04a9eca0fffc0ffe5586a5179b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c86d89a687f2ee1eb980d99c32326d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a12c86d89a687f2ee1eb980d99c32326d">I2C_close</a> (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle)</td></tr>
<tr class="memdesc:a12c86d89a687f2ee1eb980d99c32326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an I2C peripheral specified by an I2C handle.  <a href="#a12c86d89a687f2ee1eb980d99c32326d">More...</a><br /></td></tr>
<tr class="separator:a12c86d89a687f2ee1eb980d99c32326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633003582213a5098467a4e647cc52f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a633003582213a5098467a4e647cc52f9">I2C_control</a> (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle, unsigned int cmd, void *arg)</td></tr>
<tr class="memdesc:a633003582213a5098467a4e647cc52f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform implementation specific features on a given I2C_Handle.  <a href="#a633003582213a5098467a4e647cc52f9">More...</a><br /></td></tr>
<tr class="separator:a633003582213a5098467a4e647cc52f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff51ddf1d325776fef90cce0223772b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b">I2C_init</a> (void)</td></tr>
<tr class="memdesc:a9ff51ddf1d325776fef90cce0223772b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the I2C module.  <a href="#a9ff51ddf1d325776fef90cce0223772b">More...</a><br /></td></tr>
<tr class="separator:a9ff51ddf1d325776fef90cce0223772b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aa99e1fee4517406018e10025cca0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e">I2C_open</a> (unsigned int index, <a class="el" href="struct_i2_c___params.html">I2C_Params</a> *params)</td></tr>
<tr class="memdesc:ae1aa99e1fee4517406018e10025cca0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate.  <a href="#ae1aa99e1fee4517406018e10025cca0e">More...</a><br /></td></tr>
<tr class="separator:ae1aa99e1fee4517406018e10025cca0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11636302074d67180207ab81ceb323c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#ab11636302074d67180207ab81ceb323c">I2C_Params_init</a> (<a class="el" href="struct_i2_c___params.html">I2C_Params</a> *params)</td></tr>
<tr class="memdesc:ab11636302074d67180207ab81ceb323c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="struct_i2_c___params.html" title="I2C Parameters. ">I2C_Params</a> struct to its defaults.  <a href="#ab11636302074d67180207ab81ceb323c">More...</a><br /></td></tr>
<tr class="separator:ab11636302074d67180207ab81ceb323c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d827b67fe77d7d179026941cc069d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7">I2C_transfer</a> (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle, <a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a> *transaction)</td></tr>
<tr class="memdesc:ac5d827b67fe77d7d179026941cc069d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an I2C transaction with an I2C slave peripheral.  <a href="#ac5d827b67fe77d7d179026941cc069d7">More...</a><br /></td></tr>
<tr class="separator:ac5d827b67fe77d7d179026941cc069d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a5809a229f8395c87f59e63128195c1bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___config.html">I2C_Config</a>* <a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle that is returned from a <a class="el" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e" title="Initialize a given I2C peripheral specified by the particular index value. The parameter specifies wh...">I2C_open()</a> call. </p>

</div>
</div>
<a class="anchor" id="a54d2d506a10628451340a2901bdb6277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a>  <a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C transaction. </p>
<p>This structure defines the nature of the I2C transaction. This structure specifies the buffer and buffer's size that is to be written to or read from the I2C slave peripheral. arg is an optional user supplied argument that will be passed to the callback function when the I2C driver is in I2C_MODE_CALLBACK. nextPtr is to be only used by the I2C driver. </p>

</div>
</div>
<a class="anchor" id="a74176ca6d49d4081eeacb270a8e9c800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_i2_c_8h.html#a39f3b9340fc4ee241b0d2da9b2841c26">I2C_TransferMode</a>  <a class="el" href="_i2_c_8h.html#a39f3b9340fc4ee241b0d2da9b2841c26">I2C_TransferMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C transfer mode. </p>
<p>I2C_MODE_BLOCKING blocks task execution while an I2C transfer is in progress I2C_MODE_CALLBACK does not block task execution; but calls a callback function when the I2C transfer has completed </p>

</div>
</div>
<a class="anchor" id="aa7389002843eba77425c73b441358fd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* I2C_CallbackFxn) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a>, <a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a> *, bool)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C callback function. </p>
<p>User-definable callback function prototype. The I2C driver will call the defined function and pass in the I2C driver's handle, the pointer to the I2C transaction that just completed, and the return value of I2C_transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I2C_Handle</td><td>I2C_Handle</td></tr>
    <tr><td class="paramname">I2C_Transaction*</td><td>Address of the <a class="el" href="struct_i2_c___transaction.html" title="I2C transaction. ">I2C_Transaction</a> performed</td></tr>
    <tr><td class="paramname">bool</td><td>Results of the I2C transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4614c71f39459a9cc729b1f183d795f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_i2_c_8h.html#ac954e3197f04c50293db466c4abb6fbe">I2C_BitRate</a>  <a class="el" href="_i2_c_8h.html#ac954e3197f04c50293db466c4abb6fbe">I2C_BitRate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C bitRate. </p>
<p>Specify one of the standardized I2C bus bit rates for I2C communications. The default is I2C_100kHz. </p>

</div>
</div>
<a class="anchor" id="ae6b2a2e3bc3716b5716ad6c1f10d7c1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___params.html">I2C_Params</a>  <a class="el" href="struct_i2_c___params.html">I2C_Params</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Parameters. </p>
<p>I2C parameters are used with the <a class="el" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e" title="Initialize a given I2C peripheral specified by the particular index value. The parameter specifies wh...">I2C_open()</a> call. Default values for these parameters are set using <a class="el" href="_i2_c_8h.html#ab11636302074d67180207ab81ceb323c" title="Initialize an I2C_Params struct to its defaults. ">I2C_Params_init()</a>.</p>
<p>If I2C_TransferMode is set to I2C_MODE_BLOCKING then I2C_transfer function calls will block thread execution until the transaction has completed.</p>
<p>If I2C_TransferMode is set to I2C_MODE_CALLBACK then I2C_transfer will not block thread execution and it will call the function specified by transferCallbackFxn. Sequential calls to I2C_transfer in I2C_MODE_CALLBACK mode will put the designated transaction onto an internal queue that automatically starts queued transactions after the previous transaction has completed. This queuing occurs regardless of error state.</p>
<p>I2C_BitRate specifies the I2C bus rate used for I2C communications.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#ab11636302074d67180207ab81ceb323c" title="Initialize an I2C_Params struct to its defaults. ">I2C_Params_init()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a829a2a0fd594c50e93c3e55c7d04aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* I2C_CancelFxn) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a8cad0c04a9eca0fffc0ffe5586a5179b" title="Cancel all I2C transfers. ">I2C_cancel()</a>. </p>

</div>
</div>
<a class="anchor" id="a083200108e980a0ef61e458f0b9fb9e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* I2C_CloseFxn) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a12c86d89a687f2ee1eb980d99c32326d" title="Close an I2C peripheral specified by an I2C handle. ">I2C_close()</a>. </p>

</div>
</div>
<a class="anchor" id="a4b15853f98d3d5e5135b8c52b8465fff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* I2C_ControlFxn) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle, unsigned int cmd, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a633003582213a5098467a4e647cc52f9" title="Perform implementation specific features on a given I2C_Handle. ">I2C_control()</a>. </p>

</div>
</div>
<a class="anchor" id="adfb2451c8a1ce70402e43e4743c5fedf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* I2C_InitFxn) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a>. </p>

</div>
</div>
<a class="anchor" id="add24fcdaaf1bdef1521ce2489bf1d80e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a>(* I2C_OpenFxn) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle, <a class="el" href="struct_i2_c___params.html">I2C_Params</a> *params)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e" title="Initialize a given I2C peripheral specified by the particular index value. The parameter specifies wh...">I2C_open()</a>. </p>

</div>
</div>
<a class="anchor" id="aa785484e689c79262f98208689fecd38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* I2C_TransferFxn) (<a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> handle, <a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a> *transaction)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function pointer to a driver-specific implementation of <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a>. </p>

</div>
</div>
<a class="anchor" id="abdc2b5945fac9724271b088437881d68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___fxn_table.html">I2C_FxnTable</a>  <a class="el" href="struct_i2_c___fxn_table.html">I2C_FxnTable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of an I2C function table that contains the required set of functions to control a specific I2C driver implementation. </p>

</div>
</div>
<a class="anchor" id="a06eeddd0e8a5dd24a18566b65099d588"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___config.html">I2C_Config</a>  <a class="el" href="struct_i2_c___config.html">I2C_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C global configuration. </p>
<p>The <a class="el" href="struct_i2_c___config.html" title="I2C global configuration. ">I2C_Config</a> structure contains a set of pointers used to characterize the I2C driver implementation.</p>
<p>This structure needs to be defined before calling <a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a> and it must not be changed thereafter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a39f3b9340fc4ee241b0d2da9b2841c26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_i2_c_8h.html#a39f3b9340fc4ee241b0d2da9b2841c26">I2C_TransferMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C transfer mode. </p>
<p>I2C_MODE_BLOCKING blocks task execution while an I2C transfer is in progress I2C_MODE_CALLBACK does not block task execution; but calls a callback function when the I2C transfer has completed </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a39f3b9340fc4ee241b0d2da9b2841c26abe065350be2a0ae5c9beb24624626c75"></a>I2C_MODE_BLOCKING&#160;</td><td class="fielddoc">
<p>I2C_transfer blocks execution </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a39f3b9340fc4ee241b0d2da9b2841c26a129731a7edeb285f43a54b2cf9f5ac72"></a>I2C_MODE_CALLBACK&#160;</td><td class="fielddoc">
<p>I2C_transfer queues transactions and does not block </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac954e3197f04c50293db466c4abb6fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_i2_c_8h.html#ac954e3197f04c50293db466c4abb6fbe">I2C_BitRate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C bitRate. </p>
<p>Specify one of the standardized I2C bus bit rates for I2C communications. The default is I2C_100kHz. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac954e3197f04c50293db466c4abb6fbea966fd2df13b3a9825615c50335cf1987"></a>I2C_100kHz&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac954e3197f04c50293db466c4abb6fbea83cc3750242e6ae9194cd7ed94f764d9"></a>I2C_400kHz&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8cad0c04a9eca0fffc0ffe5586a5179b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel all I2C transfers. </p>
<p>This function will cancel asynchronous <a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> operations, and is applicable only for I2C_MODE_CALLBACK. An in progress transfer, as well as any queued transfers will be canceled. The individual callback functions for each transfer will be called from the context that I2C_cancel is called.</p>
<dl class="section pre"><dt>Precondition</dt><dd>I2C_Transfer() has been called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>An I2C_Handle returned from I2C_open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Different I2C slave devices will behave differently when an in-progress transfer fails and needs to be canceled. The slave may need to be reset, or there may be other slave-specifc steps that can be used to successfully resume communication.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#ac5d827b67fe77d7d179026941cc069d7" title="Perform an I2C transaction with an I2C slave peripheral. ">I2C_transfer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a12c86d89a687f2ee1eb980d99c32326d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close an I2C peripheral specified by an I2C handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e" title="Initialize a given I2C peripheral specified by the particular index value. The parameter specifies wh...">I2C_open()</a> has been called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A I2C_Handle returned from I2C_open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e" title="Initialize a given I2C peripheral specified by the particular index value. The parameter specifies wh...">I2C_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a633003582213a5098467a4e647cc52f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int I2C_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform implementation specific features on a given I2C_Handle. </p>
<p>Commands for I2C_control can originate from <a class="el" href="_i2_c_8h.html" title="I2C driver interface. ">I2C.h</a> or from implementation specific I2C*.h (<em><a class="el" href="_i2_c_c_c26_x_x_8h.html" title="I2C driver implementation for a CC26XX I2C controller. ">I2CCC26XX.h</a></em>, <em>I2CTiva.h</em>, etc.. ) files. While commands from <a class="el" href="_i2_c_8h.html" title="I2C driver interface. ">I2C.h</a> are API portable across driver implementations, not all implementations may support all these commands. Conversely, commands from driver implementation specific I2C*.h files add unique driver capabilities but are not API portable across all I2C driver implementations.</p>
<p>Commands supported by <a class="el" href="_i2_c_8h.html" title="I2C driver interface. ">I2C.h</a> follow a I2C_CMD_&lt;cmd&gt; naming convention.<br />
 Commands supported by I2C*.h follow a I2C*_CMD_&lt;cmd&gt; naming convention.<br />
 Each control command defines <b>arg</b> differently. The types of <b>arg</b> are documented with each command.</p>
<p>See <a class="el" href="group___i2_c___c_m_d.html">I2C_control command codes</a> for command codes.</p>
<p>See <a class="el" href="group___i2_c___s_t_a_t_u_s.html">I2C_control return status codes</a> for status codes.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e" title="Initialize a given I2C peripheral specified by the particular index value. The parameter specifies wh...">I2C_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A I2C handle returned from <a class="el" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e" title="Initialize a given I2C peripheral specified by the particular index value. The parameter specifies wh...">I2C_open()</a></td></tr>
    <tr><td class="paramname">cmd</td><td><a class="el" href="_i2_c_8h.html" title="I2C driver interface. ">I2C.h</a> or I2C*.h command.</td></tr>
    <tr><td class="paramname">arg</td><td>An optional R/W (read/write) command argument accompanied with cmd</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation specific return codes. Negative values indicate unsuccessful operations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e" title="Initialize a given I2C peripheral specified by the particular index value. The parameter specifies wh...">I2C_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9ff51ddf1d325776fef90cce0223772b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the I2C module. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The I2C_config structure must exist and be persistent before this function can be called. This function must also be called before any other I2C driver APIs. This function call does not modify any peripheral registers. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1aa99e1fee4517406018e10025cca0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a> I2C_open </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___params.html">I2C_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a given I2C peripheral specified by the particular index value. The parameter specifies which mode the I2C will operate. </p>
<dl class="section pre"><dt>Precondition</dt><dd>I2C controller has been initialized</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Logical peripheral number for the I2C indexed into the I2C_config table</td></tr>
    <tr><td class="paramname">params</td><td>Pointer to a parameter block. Default values will be used if NULL is specified. All the fields in this structure are are considered RO (read-only).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A I2C_Handle on success or a NULL on an error or if it has been opened already.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#a9ff51ddf1d325776fef90cce0223772b" title="Initializes the I2C module. ">I2C_init()</a> </dd>
<dd>
<a class="el" href="_i2_c_8h.html#a12c86d89a687f2ee1eb980d99c32326d" title="Close an I2C peripheral specified by an I2C handle. ">I2C_close()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab11636302074d67180207ab81ceb323c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___params.html">I2C_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="struct_i2_c___params.html" title="I2C Parameters. ">I2C_Params</a> struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>A pointer to <a class="el" href="struct_i2_c___params.html" title="I2C Parameters. ">I2C_Params</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are: transferMode = I2C_MODE_BLOCKING transferCallbackFxn = NULL bitRate = I2C_100kHz </p>

</div>
</div>
<a class="anchor" id="ac5d827b67fe77d7d179026941cc069d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2C_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_i2_c_8h.html#a5809a229f8395c87f59e63128195c1bf">I2C_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___transaction.html">I2C_Transaction</a> *&#160;</td>
          <td class="paramname"><em>transaction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an I2C transaction with an I2C slave peripheral. </p>
<p>This function will start an I2C transfer and can only be called from a Task context when in I2C_MODE_BLOCKING. The I2C transfer procedure starts with evaluating how many bytes are to be written and how many are to be read from the I2C peripheral. Any data to be written will always be sent before any data is read.</p>
<p>The data written to the peripheral is preceded with the peripheral's 7-bit I2C slave address (with the Write bit set). After all the data has been transmitted, the driver will evaluate if any data needs to be read from the device. If so, a Re-START bit is sent, along with the same 7-bit I2C slave address (with the Read bit). Else, the transfer is concluded with a STOP bit. After the specified number of bytes have been read by the I2C, the transfer is ended with a NACK and STOP bit.</p>
<p>In I2C_MODE_BLOCKING, the I2C_transfer will block task execution until the transaction completes.</p>
<p>In I2C_MODE_CALLBACK, the I2C_transfer does not block task execution. A callback function (specified by transferCallbackFxn) is called when the transfer completes. Success or failure of the transaction is reported via the callback function's bool argument. If a transfer is already in progress, the new transaction is put on an internal queue. The queue is serviced in a first come first served basis. The <a class="el" href="struct_i2_c___transaction.html" title="I2C transaction. ">I2C_Transaction</a> structure must stay persistent until the I2C_transfer function has completed!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A I2C_Handle</td></tr>
    <tr><td class="paramname">transaction</td><td>A pointer to an <a class="el" href="struct_i2_c___transaction.html" title="I2C transaction. ">I2C_Transaction</a>. All of the fields within transaction should be considered write only, unless otherwise noted in the driver implementation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In I2C_MODE_BLOCKING: true for a successful transfer; false for an error (for example, an I2C bus fault (NACK)). In I2C_MODE_CALLBACK: always true. The transferCallbackFxn's bool argument will be true to indicate success, and false on an error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_i2_c_8h.html#ae1aa99e1fee4517406018e10025cca0e" title="Initialize a given I2C peripheral specified by the particular index value. The parameter specifies wh...">I2C_open</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
Copyright  2018, Texas Instruments Incorporated
</small>
</body>
</html>
