<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>TI-RTOS Drivers: GPTimerCC26XX.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TI-RTOS Drivers
   &#160;<span id="projectnumber">tidrivers_cc13xx_cc26xx_2_21_01_01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c17777783ce38a5c07940aaaf742f522.html">exports</a></li><li class="navelem"><a class="el" href="dir_f6e916242039e0349c75a086e347d29e.html">tidrivers_cc13xx_cc26xx_2_21_01_01</a></li><li class="navelem"><a class="el" href="dir_66ebce97428d8a203c418c1e1c30b1d0.html">packages</a></li><li class="navelem"><a class="el" href="dir_bb9bb6c41181976c26c510dde001be8f.html">ti</a></li><li class="navelem"><a class="el" href="dir_3272f9f9556099c0b986cb38fa788482.html">drivers</a></li><li class="navelem"><a class="el" href="dir_59ca07a14996ae5620376416dce42b2e.html">timer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GPTimerCC26XX.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GPTimer driver implementation for CC26XX/CC13XX. </p>
<hr/>
 <pre class="fragment"># Overview #
</pre><p> This TI RTOS driver can be used to configure GPTimer modules to the modes supported by the GPTimer. The board file or application must define the device specific configuration before using the driver. </p><h1>Configuration</h1>
<p>The GPTimer can be used in two different configurations. In 32-bit mode the timer will act as a full-width timer and is controlled using the Timer A unit. In split (16-bit) mode the timer is split into 2x 16-bit timers. In 16-bit mode a prescaler is available for each timer unit, effectively increasing the resolution in this mode to 24-bit. All supported modes by driver in split configuration uses prescaler as timer extension.</p>
<h1>Modes</h1>
<p>The GPTimer driver supports the following timer modes:</p><ul>
<li>Oneshot mode counting upwards. When timer reaches load value, the timer is stopped automatically. Supported in both 16 and 32-bit configuration.</li>
<li>Periodic mode counting upwards. When timer reaches load value it wraps and starts counting from 0 again. Supported in both 16 and 32-bit configuration.</li>
<li>Input edge-count. Timer counts the number of events on its input capture port upwards from 0. Events can be rising-edge, falling-edge, or both. Supported only in 16-bit mode.</li>
<li>Input edge-time. Timer counts upwards from 0 and captures the time of an event on its input capture port. This can be used to count the time between events. Events can be rising-edge, falling-edge or both. Supported only in 16-bit mode.</li>
<li>PWM mode. Timer counts downwards from load value. CCP is set to 1 when reaching timeout (0) and toggles when reaching match value.</li>
</ul>
<h1>Power Management</h1>
<p>The TI-RTOS power management framework will try to put the device into the most power efficient mode whenever possible. Please see the technical reference manual for further details on each power mode.</p>
<p>The GPTimerCC26XX driver will set constraints on disallowed power modes when needed, removing the need for the application to handle this. The following statements are valid:</p><ul>
<li>After <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a>: The device is still allowed to enter Standby. When the device is active the corresponding GPTimer peripheral will be enabled and clocked.</li>
<li>After <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a869213ede8949245112fd7ca9c9ebdaa" title="Function to start the specified GPTimer with current settings. ">GPTimerCC26XX_start()</a>: The device will only go to Idle power mode since the high-frequency clock is needed for timer operation.</li>
<li>After <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aebdbd7f83c3824555e4abb7399802765" title="Function to stop the specified GPTimer. ">GPTimerCC26XX_stop()</a>: Conditions are equal as for after GPTimerCC26XX_open</li>
<li>After <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a0a148f2232f5bb4c59015de965c82d43" title="Function to close a GPTimer peripheral specified by the GPTimer handle. Closing timer will releae dep...">GPTimerCC26XX_close()</a>: The underlying GPTimer is turned off and the device is allowed to go to standby.</li>
</ul>
<h1>Accuracy</h1>
<p>The GPTimer clock is dependent on the MCU system clock. If very high-accuracy outputs are needed, the application should request using the external HF crystal: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ti/sysbios/family/arm/cc26xx/Power.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ti/sysbios/family/arm/cc26xx/PowerCC2650.h&gt;</span></div>
<div class="line"><a class="code" href="_power_8h.html#a2f2f4dfed7da8eed50a5b82e2bad26b5">Power_setDependency</a>(XOSC_HF);</div>
</div><!-- fragment --><h1>Limitations</h1>
<ul>
<li>DMA usage is not supported</li>
<li>Timer synchronization is not supported</li>
<li>Down counting modes (except for PWM) are not supported by driver</li>
</ul>
<h1>GPTimerCC26XX usage</h1>
<h2>Periodic timer</h2>
<p>The example below will generate an interrupt using the GPTimer every 1 ms.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_g_p_timer_c_c26_x_x___config.html">GPTimerCC26XX_Handle</a> hTimer;</div>
<div class="line"><span class="keywordtype">void</span> timerCallback(<a class="code" href="struct_g_p_timer_c_c26_x_x___config.html">GPTimerCC26XX_Handle</a> handle, <a class="code" href="_g_p_timer_c_c26_x_x_8h.html#ac74410bfd92bf89732dd795bbe8769d1">GPTimerCC26XX_IntMask</a> interruptMask) {</div>
<div class="line">    <span class="comment">// interrupt callback code goes here. Minimize processing in interrupt.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> taskFxn(UArg a0, UArg a1) {</div>
<div class="line">  <a class="code" href="struct_g_p_timer_c_c26_x_x___params.html">GPTimerCC26XX_Params</a> params;</div>
<div class="line">  <a class="code" href="_g_p_timer_c_c26_x_x_8h.html#a11e9f3ff24f5f075989f89d99e65e827">GPTimerCC26XX_Params_init</a>(&amp;params);</div>
<div class="line">  params.<a class="code" href="struct_g_p_timer_c_c26_x_x___params.html#a4c9e040425769960160b4d42496f5aec">width</a>          = <a class="code" href="_g_p_timer_c_c26_x_x_8h.html#a37f7594eb4084eff43d5b80bb6418ec7a2e5a3c43a8c62eeace6b38800d39392f">GPT_CONFIG_16BIT</a>;</div>
<div class="line">  params.<a class="code" href="struct_g_p_timer_c_c26_x_x___params.html#ae911c92ad3079146c568a02575bb6300">mode</a>           = <a class="code" href="_g_p_timer_c_c26_x_x_8h.html#ac3f0539fd948c59b31df04dff5b7024ca0c73c880888fc8da201a44bb87980578">GPT_MODE_PERIODIC_UP</a>;</div>
<div class="line">  params.<a class="code" href="struct_g_p_timer_c_c26_x_x___params.html#aebaace525be6fc274c77ff655f604754">debugStallMode</a> = <a class="code" href="_g_p_timer_c_c26_x_x_8h.html#ab4c80c79c9acaf8e482e8244adbae73ea1aca5e7c45ce80046cc86c309b1500b3">GPTimerCC26XX_DEBUG_STALL_OFF</a>;</div>
<div class="line">  hTimer = <a class="code" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b">GPTimerCC26XX_open</a>(CC2650_GPTIMER0A, &amp;params);</div>
<div class="line">  <span class="keywordflow">if</span>(hTimer == NULL) {</div>
<div class="line">    Log_error0(<span class="stringliteral">&quot;Failed to open GPTimer&quot;</span>);</div>
<div class="line">    Task_exit();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  Types_FreqHz  freq;</div>
<div class="line">  BIOS_getCpuFreq(&amp;freq);</div>
<div class="line">  <a class="code" href="_g_p_timer_c_c26_x_x_8h.html#ab667a2fd47273a9778f5011774fa55c0">GPTimerCC26XX_Value</a> loadVal = freq.lo / 1000 - 1; <span class="comment">//47999</span></div>
<div class="line">  <a class="code" href="_g_p_timer_c_c26_x_x_8h.html#aa365d9e1d6a1b324090510f2748db771">GPTimerCC26XX_setLoadValue</a>(hTimer, loadVal);</div>
<div class="line">  <a class="code" href="_g_p_timer_c_c26_x_x_8h.html#a4032d544f2b79ae1a999a4faa5ee0884">GPTimerCC26XX_registerInterrupt</a>(hTimer, timerCallback, <a class="code" href="_g_p_timer_c_c26_x_x_8h.html#a1e0397cdf2412358dfdf0eb0df40db92a6c6f5236dcbe5f37289a4a513451851e">GPT_INT_TIMEOUT</a>);</div>
<div class="line"></div>
<div class="line">  <a class="code" href="_g_p_timer_c_c26_x_x_8h.html#a869213ede8949245112fd7ca9c9ebdaa">GPTimerCC26XX_start</a>(hTimer);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">while</span>(1) {</div>
<div class="line">    Task_sleep(BIOS_WAIT_FOREVER);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2>PWM output</h2>
<p>See the PWM2TimerCC26XX driver </p>
</div><div class="textblock"><code>#include &lt;xdc/std.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;ti/sysbios/family/arm/m3/Hwi.h&gt;</code><br />
<code>#include &lt;driverlib/event.h&gt;</code><br />
<code>#include &lt;driverlib/ioc.h&gt;</code><br />
<code>#include &lt;driverlib/timer.h&gt;</code><br />
<code>#include &lt;inc/hw_gpt.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for GPTimerCC26XX.h:</div>
<div class="dyncontent">
<div class="center"><img src="_g_p_timer_c_c26_x_x_8h__incl.png" border="0" usemap="#_g_p_timer_c_c26_x_x_8h" alt=""/></div>
<map name="_g_p_timer_c_c26_x_x_8h" id="_g_p_timer_c_c26_x_x_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_g_p_timer_c_c26_x_x_8h__dep__incl.png" border="0" usemap="#_g_p_timer_c_c26_x_x_8hdep" alt=""/></div>
<map name="_g_p_timer_c_c26_x_x_8hdep" id="_g_p_timer_c_c26_x_x_8hdep">
<area shape="rect" href="_a_d_c_buf_c_c26_x_x_8h.html" title="ADCBuf driver implementation for a CC26XX analog&#45;to&#45;digital converter. " alt="" coords="8,83,138,107" /><area shape="rect" href="_p_w_m_timer_c_c26_x_x_8h.html" title="PWM driver implementation for CC26XX/CC13XX. " alt="" coords="162,83,312,107" /></map>
</div>
</div>
<p><a href="_g_p_timer_c_c26_x_x_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_p_timer_c_c26_x_x___h_w_attrs.html">GPTimerCC26XX_HWAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPTimer26XX Hardware attributes.  <a href="struct_g_p_timer_c_c26_x_x___h_w_attrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_p_timer_c_c26_x_x___object.html">GPTimerCC26XX_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPTimer26XX Object.  <a href="struct_g_p_timer_c_c26_x_x___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_p_timer_c_c26_x_x___config.html">GPTimerCC26XX_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPTimer Global configuration.  <a href="struct_g_p_timer_c_c26_x_x___config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_p_timer_c_c26_x_x___params.html">GPTimerCC26XX_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPTimerCC26XX Parameters.  <a href="struct_g_p_timer_c_c26_x_x___params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae8166f42d637bc48b784b2524e49d0fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ae8166f42d637bc48b784b2524e49d0fe">GPT_NUM_INTS</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ae8166f42d637bc48b784b2524e49d0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeb2b955f6dda2b101294c7b521e715b4"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a37f7594eb4084eff43d5b80bb6418ec7">GPTimerCC26XX_Width</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aeb2b955f6dda2b101294c7b521e715b4">GPTimerCC26XX_Width</a></td></tr>
<tr class="memdesc:aeb2b955f6dda2b101294c7b521e715b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for specifying the GPTimer configuration (width)  <a href="#aeb2b955f6dda2b101294c7b521e715b4">More...</a><br /></td></tr>
<tr class="separator:aeb2b955f6dda2b101294c7b521e715b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c88da09d4f9806f5555690bf2e3a49"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac3f0539fd948c59b31df04dff5b7024c">GPTimerCC26XX_Mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a13c88da09d4f9806f5555690bf2e3a49">GPTimerCC26XX_Mode</a></td></tr>
<tr class="memdesc:a13c88da09d4f9806f5555690bf2e3a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for supported GPTimer modes. Driver code assumes only modes using prescaler as timer extension in 16-bit configuration are used. Therefore new modes must not be added to the below description without also updating driver.  <a href="#a13c88da09d4f9806f5555690bf2e3a49">More...</a><br /></td></tr>
<tr class="separator:a13c88da09d4f9806f5555690bf2e3a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cc2366361f3ae2d3438d4496e6b184"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a1e0397cdf2412358dfdf0eb0df40db92">GPTimerCC26XX_Interrupt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aa4cc2366361f3ae2d3438d4496e6b184">GPTimerCC26XX_Interrupt</a></td></tr>
<tr class="memdesc:aa4cc2366361f3ae2d3438d4496e6b184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for supported GPTimer interrupts. GPTimerCC26XX_IntMask arguments should be a bit vector containing these definitions. See description in Technical Reference.  <a href="#aa4cc2366361f3ae2d3438d4496e6b184">More...</a><br /></td></tr>
<tr class="separator:aa4cc2366361f3ae2d3438d4496e6b184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7067a38f9de14af167de8df90dfb18d3"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aff5462fa33c306f2c8bd29284fd898b0">GPTimerCC26XX_Part</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a7067a38f9de14af167de8df90dfb18d3">GPTimerCC26XX_Part</a></td></tr>
<tr class="memdesc:a7067a38f9de14af167de8df90dfb18d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for GPTimer parts (Timer A / Timer B). Used in GPTimer configuration structure GPTimerCC26XX_config to configure the corresponding timer unit.  <a href="#a7067a38f9de14af167de8df90dfb18d3">More...</a><br /></td></tr>
<tr class="separator:a7067a38f9de14af167de8df90dfb18d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bcd903a770b3bc9bea666cf5b0bded"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359">GPTimerCC26XX_PinMux</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a02bcd903a770b3bc9bea666cf5b0bded">GPTimerCC26XX_PinMux</a></td></tr>
<tr class="memdesc:a02bcd903a770b3bc9bea666cf5b0bded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for input / output ports in IO controller to connect GPTimer to a pin. Used in gptimerCC26xxHWAttrs for static timer configuration PIN driver is used to mux a pin to the timer.  <a href="#a02bcd903a770b3bc9bea666cf5b0bded">More...</a><br /></td></tr>
<tr class="separator:a02bcd903a770b3bc9bea666cf5b0bded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5a4b610efe0481e6ebf9575820a6f3"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4c80c79c9acaf8e482e8244adbae73e">GPTimerCC26XX_DebugMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a1c5a4b610efe0481e6ebf9575820a6f3">GPTimerCC26XX_DebugMode</a></td></tr>
<tr class="memdesc:a1c5a4b610efe0481e6ebf9575820a6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for controlling timer debug stall mode.  <a href="#a1c5a4b610efe0481e6ebf9575820a6f3">More...</a><br /></td></tr>
<tr class="separator:a1c5a4b610efe0481e6ebf9575820a6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b251408c3c97a16d017a095555aa18"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac72f25419727329702ec162a2b6b9151">GPTimerCC26XX_Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a32b251408c3c97a16d017a095555aa18">GPTimerCC26XX_Edge</a></td></tr>
<tr class="memdesc:a32b251408c3c97a16d017a095555aa18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for controlling edges used for timer capture. Used in GPTimer edge-time and edge-count modes.  <a href="#a32b251408c3c97a16d017a095555aa18">More...</a><br /></td></tr>
<tr class="separator:a32b251408c3c97a16d017a095555aa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a5955bada127ddac4d46b55f86b848"><td class="memItemLeft" align="right" valign="top">typedef const struct <a class="el" href="struct_g_p_timer_c_c26_x_x___config.html">GPTimerCC26XX_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aa5a5955bada127ddac4d46b55f86b848">GPTimerCC26XX_Config</a></td></tr>
<tr class="separator:aa5a5955bada127ddac4d46b55f86b848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85403dde5940c587c57ca1a140e655a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_g_p_timer_c_c26_x_x___config.html">GPTimerCC26XX_Config</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a></td></tr>
<tr class="separator:ab85403dde5940c587c57ca1a140e655a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74410bfd92bf89732dd795bbe8769d1"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac74410bfd92bf89732dd795bbe8769d1">GPTimerCC26XX_IntMask</a></td></tr>
<tr class="separator:ac74410bfd92bf89732dd795bbe8769d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab667a2fd47273a9778f5011774fa55c0"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab667a2fd47273a9778f5011774fa55c0">GPTimerCC26XX_Value</a></td></tr>
<tr class="separator:ab667a2fd47273a9778f5011774fa55c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9b95974e20f85ccd3f8463fdda84f1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a6b9b95974e20f85ccd3f8463fdda84f1">GPTimerCC26XX_HwiFxn</a>) (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle, <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac74410bfd92bf89732dd795bbe8769d1">GPTimerCC26XX_IntMask</a> interruptMask)</td></tr>
<tr class="separator:a6b9b95974e20f85ccd3f8463fdda84f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415d99f6aca4a4a8bf94a6328021c15c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_g_p_timer_c_c26_x_x___h_w_attrs.html">GPTimerCC26XX_HWAttrs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a415d99f6aca4a4a8bf94a6328021c15c">GPTimerCC26XX_HWAttrs</a></td></tr>
<tr class="memdesc:a415d99f6aca4a4a8bf94a6328021c15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPTimer26XX Hardware attributes.  <a href="#a415d99f6aca4a4a8bf94a6328021c15c">More...</a><br /></td></tr>
<tr class="separator:a415d99f6aca4a4a8bf94a6328021c15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c0a6722f2d48af3b7c032235181bd1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_g_p_timer_c_c26_x_x___object.html">GPTimerCC26XX_Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a98c0a6722f2d48af3b7c032235181bd1">GPTimerCC26XX_Object</a></td></tr>
<tr class="memdesc:a98c0a6722f2d48af3b7c032235181bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPTimer26XX Object.  <a href="#a98c0a6722f2d48af3b7c032235181bd1">More...</a><br /></td></tr>
<tr class="separator:a98c0a6722f2d48af3b7c032235181bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5264b3636e1d40a6cbd64cf150be32d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_g_p_timer_c_c26_x_x___params.html">GPTimerCC26XX_Params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ad5264b3636e1d40a6cbd64cf150be32d">GPTimerCC26XX_Params</a></td></tr>
<tr class="memdesc:ad5264b3636e1d40a6cbd64cf150be32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPTimerCC26XX Parameters.  <a href="#ad5264b3636e1d40a6cbd64cf150be32d">More...</a><br /></td></tr>
<tr class="separator:ad5264b3636e1d40a6cbd64cf150be32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a37f7594eb4084eff43d5b80bb6418ec7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a37f7594eb4084eff43d5b80bb6418ec7">GPTimerCC26XX_Width</a> { <br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a37f7594eb4084eff43d5b80bb6418ec7afbeda4c45001e3d32d50f576d6259016">GPT_CONFIG_32BIT</a> = GPT_CFG_CFG_32BIT_TIMER, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a37f7594eb4084eff43d5b80bb6418ec7a2e5a3c43a8c62eeace6b38800d39392f">GPT_CONFIG_16BIT</a> = GPT_CFG_CFG_16BIT_TIMER
<br />
 }</td></tr>
<tr class="memdesc:a37f7594eb4084eff43d5b80bb6418ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for specifying the GPTimer configuration (width)  <a href="_g_p_timer_c_c26_x_x_8h.html#a37f7594eb4084eff43d5b80bb6418ec7">More...</a><br /></td></tr>
<tr class="separator:a37f7594eb4084eff43d5b80bb6418ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f0539fd948c59b31df04dff5b7024c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac3f0539fd948c59b31df04dff5b7024c">GPTimerCC26XX_Mode</a> { <br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac3f0539fd948c59b31df04dff5b7024ca945157a7df9978aef69f2bc5d08328a5">GPT_MODE_ONESHOT_UP</a>, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac3f0539fd948c59b31df04dff5b7024ca0c73c880888fc8da201a44bb87980578">GPT_MODE_PERIODIC_UP</a>, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac3f0539fd948c59b31df04dff5b7024ca8336182ae5bd6521222c07d159b22459">GPT_MODE_EDGE_COUNT_UP</a>, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac3f0539fd948c59b31df04dff5b7024ca3d1702ae14a42f1af112fb88b7fd7c77">GPT_MODE_EDGE_TIME_UP</a>, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac3f0539fd948c59b31df04dff5b7024ca5d09320529435b9b021abd37d4dac117">GPT_MODE_PWM</a>
<br />
 }</td></tr>
<tr class="memdesc:ac3f0539fd948c59b31df04dff5b7024c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for supported GPTimer modes. Driver code assumes only modes using prescaler as timer extension in 16-bit configuration are used. Therefore new modes must not be added to the below description without also updating driver.  <a href="_g_p_timer_c_c26_x_x_8h.html#ac3f0539fd948c59b31df04dff5b7024c">More...</a><br /></td></tr>
<tr class="separator:ac3f0539fd948c59b31df04dff5b7024c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0397cdf2412358dfdf0eb0df40db92"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a1e0397cdf2412358dfdf0eb0df40db92">GPTimerCC26XX_Interrupt</a> { <br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a1e0397cdf2412358dfdf0eb0df40db92a6c6f5236dcbe5f37289a4a513451851e">GPT_INT_TIMEOUT</a> = 1 &lt;&lt; 0, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a1e0397cdf2412358dfdf0eb0df40db92a438a33e76043ddb51f1c9e93820a8040">GPT_INT_CAPTURE_MATCH</a> = 1 &lt;&lt; 1, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a1e0397cdf2412358dfdf0eb0df40db92ae3e86fdcf14f9ff34c92aaf953b159d9">GPT_INT_CAPTURE</a> = 1 &lt;&lt; 2, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a1e0397cdf2412358dfdf0eb0df40db92a87f843ea54618ca92890d4db7f38f242">GPT_INT_MATCH</a> = 1 &lt;&lt; 3
<br />
 }</td></tr>
<tr class="memdesc:a1e0397cdf2412358dfdf0eb0df40db92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for supported GPTimer interrupts. GPTimerCC26XX_IntMask arguments should be a bit vector containing these definitions. See description in Technical Reference.  <a href="_g_p_timer_c_c26_x_x_8h.html#a1e0397cdf2412358dfdf0eb0df40db92">More...</a><br /></td></tr>
<tr class="separator:a1e0397cdf2412358dfdf0eb0df40db92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5462fa33c306f2c8bd29284fd898b0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aff5462fa33c306f2c8bd29284fd898b0">GPTimerCC26XX_Part</a> { <br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aff5462fa33c306f2c8bd29284fd898b0a0630f8ce6004469fe81ebbc804e7ac2a">GPT_A</a> = 0, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aff5462fa33c306f2c8bd29284fd898b0a09aae74a0a9878654fa701a70b76387b">GPT_B</a>, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aff5462fa33c306f2c8bd29284fd898b0a492b59ed96b96d5bddcdee40e78712b0">GPT_PARTS_COUNT</a>
<br />
 }</td></tr>
<tr class="memdesc:aff5462fa33c306f2c8bd29284fd898b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for GPTimer parts (Timer A / Timer B). Used in GPTimer configuration structure GPTimerCC26XX_config to configure the corresponding timer unit.  <a href="_g_p_timer_c_c26_x_x_8h.html#aff5462fa33c306f2c8bd29284fd898b0">More...</a><br /></td></tr>
<tr class="separator:aff5462fa33c306f2c8bd29284fd898b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a2e82c659e0ea1fa2ae7a852298359"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359">GPTimerCC26XX_PinMux</a> { <br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359a46af9b3278d2116fd4862c7fe19624b7">GPT_PIN_0A</a> = IOC_PORT_MCU_PORT_EVENT0, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359a1e7ba339de898f1572f21424ce125f2d">GPT_PIN_0B</a> = IOC_PORT_MCU_PORT_EVENT1, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359acc7f9d714b4eb87595ebd5a8fdd6ed2f">GPT_PIN_1A</a> = IOC_PORT_MCU_PORT_EVENT2, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359a69db29a9a9029d1fcfabfbf20ba26ee4">GPT_PIN_1B</a> = IOC_PORT_MCU_PORT_EVENT3, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359a48b2ab2ad9e83e67d94421adb06f4aa1">GPT_PIN_2A</a> = IOC_PORT_MCU_PORT_EVENT4, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359a3e1fd803b55127a98c4709cc9e811e70">GPT_PIN_2B</a> = IOC_PORT_MCU_PORT_EVENT5, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359a4b93799cba930f4b538d0f0b3bfee4be">GPT_PIN_3A</a> = IOC_PORT_MCU_PORT_EVENT6, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359aca82a1cd0f9e891472b4f5b09998a597">GPT_PIN_3B</a> = IOC_PORT_MCU_PORT_EVENT7
<br />
 }</td></tr>
<tr class="memdesc:ab4a2e82c659e0ea1fa2ae7a852298359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for input / output ports in IO controller to connect GPTimer to a pin. Used in gptimerCC26xxHWAttrs for static timer configuration PIN driver is used to mux a pin to the timer.  <a href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359">More...</a><br /></td></tr>
<tr class="separator:ab4a2e82c659e0ea1fa2ae7a852298359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c80c79c9acaf8e482e8244adbae73e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4c80c79c9acaf8e482e8244adbae73e">GPTimerCC26XX_DebugMode</a> { <br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4c80c79c9acaf8e482e8244adbae73ea1aca5e7c45ce80046cc86c309b1500b3">GPTimerCC26XX_DEBUG_STALL_OFF</a> = 0, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4c80c79c9acaf8e482e8244adbae73ea78ecad7414438f969450881393850b8c">GPTimerCC26XX_DEBUG_STALL_ON</a>
<br />
 }</td></tr>
<tr class="memdesc:ab4c80c79c9acaf8e482e8244adbae73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for controlling timer debug stall mode.  <a href="_g_p_timer_c_c26_x_x_8h.html#ab4c80c79c9acaf8e482e8244adbae73e">More...</a><br /></td></tr>
<tr class="separator:ab4c80c79c9acaf8e482e8244adbae73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72f25419727329702ec162a2b6b9151"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac72f25419727329702ec162a2b6b9151">GPTimerCC26XX_Edge</a> { <br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac72f25419727329702ec162a2b6b9151a0dda532d331ac235bead20fad3975f4f">GPTimerCC26XX_POS_EDGE</a> = GPT_CTL_TAEVENT_POS, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac72f25419727329702ec162a2b6b9151a2189f990a1c45892bdfcb31855d7d98f">GPTimerCC26XX_NEG_EDGE</a> = GPT_CTL_TAEVENT_NEG, 
<br />
&#160;&#160;<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac72f25419727329702ec162a2b6b9151a2219c0e15065a692a80b4049036cd20a">GPTimerCC26XX_BOTH_EDGES</a> = GPT_CTL_TAEVENT_BOTH
<br />
 }</td></tr>
<tr class="memdesc:ac72f25419727329702ec162a2b6b9151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for controlling edges used for timer capture. Used in GPTimer edge-time and edge-count modes.  <a href="_g_p_timer_c_c26_x_x_8h.html#ac72f25419727329702ec162a2b6b9151">More...</a><br /></td></tr>
<tr class="separator:ac72f25419727329702ec162a2b6b9151"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a11e9f3ff24f5f075989f89d99e65e827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a11e9f3ff24f5f075989f89d99e65e827">GPTimerCC26XX_Params_init</a> (<a class="el" href="struct_g_p_timer_c_c26_x_x___params.html">GPTimerCC26XX_Params</a> *params)</td></tr>
<tr class="memdesc:a11e9f3ff24f5f075989f89d99e65e827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the <a class="el" href="struct_g_p_timer_c_c26_x_x___params.html" title="GPTimerCC26XX Parameters. ">GPTimerCC26XX_Params</a> struct to its default values.  <a href="#a11e9f3ff24f5f075989f89d99e65e827">More...</a><br /></td></tr>
<tr class="separator:a11e9f3ff24f5f075989f89d99e65e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f6c028f0abea0b35c3be3d1609ea9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b">GPTimerCC26XX_open</a> (unsigned int index, const <a class="el" href="struct_g_p_timer_c_c26_x_x___params.html">GPTimerCC26XX_Params</a> *params)</td></tr>
<tr class="memdesc:a30f6c028f0abea0b35c3be3d1609ea9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into specified mode.  <a href="#a30f6c028f0abea0b35c3be3d1609ea9b">More...</a><br /></td></tr>
<tr class="separator:a30f6c028f0abea0b35c3be3d1609ea9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a148f2232f5bb4c59015de965c82d43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a0a148f2232f5bb4c59015de965c82d43">GPTimerCC26XX_close</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle)</td></tr>
<tr class="memdesc:a0a148f2232f5bb4c59015de965c82d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to close a GPTimer peripheral specified by the GPTimer handle. Closing timer will releae dependency on timer and clear configuration.  <a href="#a0a148f2232f5bb4c59015de965c82d43">More...</a><br /></td></tr>
<tr class="separator:a0a148f2232f5bb4c59015de965c82d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869213ede8949245112fd7ca9c9ebdaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a869213ede8949245112fd7ca9c9ebdaa">GPTimerCC26XX_start</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle)</td></tr>
<tr class="memdesc:a869213ede8949245112fd7ca9c9ebdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to start the specified GPTimer with current settings.  <a href="#a869213ede8949245112fd7ca9c9ebdaa">More...</a><br /></td></tr>
<tr class="separator:a869213ede8949245112fd7ca9c9ebdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdbd7f83c3824555e4abb7399802765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aebdbd7f83c3824555e4abb7399802765">GPTimerCC26XX_stop</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle)</td></tr>
<tr class="memdesc:aebdbd7f83c3824555e4abb7399802765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to stop the specified GPTimer.  <a href="#aebdbd7f83c3824555e4abb7399802765">More...</a><br /></td></tr>
<tr class="separator:aebdbd7f83c3824555e4abb7399802765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa365d9e1d6a1b324090510f2748db771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aa365d9e1d6a1b324090510f2748db771">GPTimerCC26XX_setLoadValue</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle, <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab667a2fd47273a9778f5011774fa55c0">GPTimerCC26XX_Value</a> loadValue)</td></tr>
<tr class="memdesc:aa365d9e1d6a1b324090510f2748db771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set load value of the specified GPTimer. Function can be called while GPTimer is running.  <a href="#aa365d9e1d6a1b324090510f2748db771">More...</a><br /></td></tr>
<tr class="separator:aa365d9e1d6a1b324090510f2748db771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f83bdcc8482297952f6e08ccadd0e11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a3f83bdcc8482297952f6e08ccadd0e11">GPTimerCC26XX_setMatchValue</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle, <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab667a2fd47273a9778f5011774fa55c0">GPTimerCC26XX_Value</a> matchValue)</td></tr>
<tr class="memdesc:a3f83bdcc8482297952f6e08ccadd0e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set match value of the specified GPTimer. Function can be called while GPTimer is running.  <a href="#a3f83bdcc8482297952f6e08ccadd0e11">More...</a><br /></td></tr>
<tr class="separator:a3f83bdcc8482297952f6e08ccadd0e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a091f0962d33a7897ae61b501aedc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ae6a091f0962d33a7897ae61b501aedc4">GPTimerCC26XX_setCaptureEdge</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle, <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac72f25419727329702ec162a2b6b9151">GPTimerCC26XX_Edge</a> edge)</td></tr>
<tr class="memdesc:ae6a091f0962d33a7897ae61b501aedc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set which input edge the GPTimer capture should use. Applies to edge-count and edge-time modes Function can be called while GPTimer is running.  <a href="#ae6a091f0962d33a7897ae61b501aedc4">More...</a><br /></td></tr>
<tr class="separator:ae6a091f0962d33a7897ae61b501aedc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4832251ebc2e81a952bbc1c39d2502e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab667a2fd47273a9778f5011774fa55c0">GPTimerCC26XX_Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#af4832251ebc2e81a952bbc1c39d2502e">GPTimerCC26XX_getFreeRunValue</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle)</td></tr>
<tr class="memdesc:af4832251ebc2e81a952bbc1c39d2502e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to retrieve the current free-running value of timer.  <a href="#af4832251ebc2e81a952bbc1c39d2502e">More...</a><br /></td></tr>
<tr class="separator:af4832251ebc2e81a952bbc1c39d2502e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553ef86139c25234964c81783aa2cd94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab667a2fd47273a9778f5011774fa55c0">GPTimerCC26XX_Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a553ef86139c25234964c81783aa2cd94">GPTimerCC26XX_getValue</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle)</td></tr>
<tr class="memdesc:a553ef86139c25234964c81783aa2cd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to retrieve the current value of timer This returns the value of the timer in all modes except for input edge count and input edge time mode. In edge count mode, this register contains the number of edges that have occurred. In input edge time, this register contains the timer value at which the last edge event took place.  <a href="#a553ef86139c25234964c81783aa2cd94">More...</a><br /></td></tr>
<tr class="separator:a553ef86139c25234964c81783aa2cd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4032d544f2b79ae1a999a4faa5ee0884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a4032d544f2b79ae1a999a4faa5ee0884">GPTimerCC26XX_registerInterrupt</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle, <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a6b9b95974e20f85ccd3f8463fdda84f1">GPTimerCC26XX_HwiFxn</a> callback, <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac74410bfd92bf89732dd795bbe8769d1">GPTimerCC26XX_IntMask</a> intMask)</td></tr>
<tr class="memdesc:a4032d544f2b79ae1a999a4faa5ee0884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to register a CPU interrupt for a given timer handle and enable a set of timer interrupt sources. The interrupt to the CPU will be a bitwise OR of the enabled interrupt sources. When an interrupt occurs, the driver will clear the interrupt source and call the application provided callback. The callback is executed in HW interrupt context and processing in callback should be minimized.  <a href="#a4032d544f2b79ae1a999a4faa5ee0884">More...</a><br /></td></tr>
<tr class="separator:a4032d544f2b79ae1a999a4faa5ee0884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0a8716a4197bba10d67322c3dfe5ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#adf0a8716a4197bba10d67322c3dfe5ac">GPTimerCC26XX_unregisterInterrupt</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle)</td></tr>
<tr class="memdesc:adf0a8716a4197bba10d67322c3dfe5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to disable a CPU interrupt for a given timer handle and disable all interrupt sources for corresponding GPTimer unit.  <a href="#adf0a8716a4197bba10d67322c3dfe5ac">More...</a><br /></td></tr>
<tr class="separator:adf0a8716a4197bba10d67322c3dfe5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08557caa1e95c615a17428521d22d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#af08557caa1e95c615a17428521d22d9d">GPTimerCC26XX_enableInterrupt</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle, <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac74410bfd92bf89732dd795bbe8769d1">GPTimerCC26XX_IntMask</a> interruptMask)</td></tr>
<tr class="memdesc:af08557caa1e95c615a17428521d22d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to enable a set of GPTimer interrupt sources. The interrupt to the CPU must be enabled using GPTimerCC26XX_registerInterrupt.  <a href="#af08557caa1e95c615a17428521d22d9d">More...</a><br /></td></tr>
<tr class="separator:af08557caa1e95c615a17428521d22d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aca62c518c9ff0347ec09f464b88b26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a8aca62c518c9ff0347ec09f464b88b26">GPTimerCC26XX_disableInterrupt</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle, <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac74410bfd92bf89732dd795bbe8769d1">GPTimerCC26XX_IntMask</a> interruptMask)</td></tr>
<tr class="memdesc:a8aca62c518c9ff0347ec09f464b88b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to disable a set of GPTimer interrupt sources.  <a href="#a8aca62c518c9ff0347ec09f464b88b26">More...</a><br /></td></tr>
<tr class="separator:a8aca62c518c9ff0347ec09f464b88b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8bdc7643305d21dcfcd567d215b7f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a5a8bdc7643305d21dcfcd567d215b7f8">GPTimerCC26XX_configureDebugStall</a> (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle, <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4c80c79c9acaf8e482e8244adbae73e">GPTimerCC26XX_DebugMode</a> mode)</td></tr>
<tr class="memdesc:a5a8bdc7643305d21dcfcd567d215b7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to control timer debug stall mode. When enabled, the timer will stop when the debugger halts the CPU.  <a href="#a5a8bdc7643305d21dcfcd567d215b7f8">More...</a><br /></td></tr>
<tr class="separator:a5a8bdc7643305d21dcfcd567d215b7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ae8166f42d637bc48b784b2524e49d0fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPT_NUM_INTS&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aeb2b955f6dda2b101294c7b521e715b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a37f7594eb4084eff43d5b80bb6418ec7">GPTimerCC26XX_Width</a>  <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a37f7594eb4084eff43d5b80bb6418ec7">GPTimerCC26XX_Width</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for specifying the GPTimer configuration (width) </p>

</div>
</div>
<a class="anchor" id="a13c88da09d4f9806f5555690bf2e3a49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac3f0539fd948c59b31df04dff5b7024c">GPTimerCC26XX_Mode</a>  <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac3f0539fd948c59b31df04dff5b7024c">GPTimerCC26XX_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for supported GPTimer modes. Driver code assumes only modes using prescaler as timer extension in 16-bit configuration are used. Therefore new modes must not be added to the below description without also updating driver. </p>

</div>
</div>
<a class="anchor" id="aa4cc2366361f3ae2d3438d4496e6b184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a1e0397cdf2412358dfdf0eb0df40db92">GPTimerCC26XX_Interrupt</a>  <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a1e0397cdf2412358dfdf0eb0df40db92">GPTimerCC26XX_Interrupt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for supported GPTimer interrupts. GPTimerCC26XX_IntMask arguments should be a bit vector containing these definitions. See description in Technical Reference. </p>

</div>
</div>
<a class="anchor" id="a7067a38f9de14af167de8df90dfb18d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aff5462fa33c306f2c8bd29284fd898b0">GPTimerCC26XX_Part</a>  <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aff5462fa33c306f2c8bd29284fd898b0">GPTimerCC26XX_Part</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for GPTimer parts (Timer A / Timer B). Used in GPTimer configuration structure GPTimerCC26XX_config to configure the corresponding timer unit. </p>

</div>
</div>
<a class="anchor" id="a02bcd903a770b3bc9bea666cf5b0bded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359">GPTimerCC26XX_PinMux</a>  <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359">GPTimerCC26XX_PinMux</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for input / output ports in IO controller to connect GPTimer to a pin. Used in gptimerCC26xxHWAttrs for static timer configuration PIN driver is used to mux a pin to the timer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_p_i_n_c_c26_x_x_8h.html#ac8cbb649db80dd03d8e8a487aef43294" title="Connect pin to HW peripheral, signal or to GPIO. ">PINCC26XX_setMux</a> </dd>
<dd>
GPTimerCC26XX_getPinMux </dd></dl>

</div>
</div>
<a class="anchor" id="a1c5a4b610efe0481e6ebf9575820a6f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4c80c79c9acaf8e482e8244adbae73e">GPTimerCC26XX_DebugMode</a>  <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4c80c79c9acaf8e482e8244adbae73e">GPTimerCC26XX_DebugMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for controlling timer debug stall mode. </p>

</div>
</div>
<a class="anchor" id="a32b251408c3c97a16d017a095555aa18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac72f25419727329702ec162a2b6b9151">GPTimerCC26XX_Edge</a>  <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac72f25419727329702ec162a2b6b9151">GPTimerCC26XX_Edge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for controlling edges used for timer capture. Used in GPTimer edge-time and edge-count modes. </p>

</div>
</div>
<a class="anchor" id="aa5a5955bada127ddac4d46b55f86b848"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const struct <a class="el" href="struct_g_p_timer_c_c26_x_x___config.html">GPTimerCC26XX_Config</a> <a class="el" href="struct_g_p_timer_c_c26_x_x___config.html">GPTimerCC26XX_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab85403dde5940c587c57ca1a140e655a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_g_p_timer_c_c26_x_x___config.html">GPTimerCC26XX_Config</a>* <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac74410bfd92bf89732dd795bbe8769d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac74410bfd92bf89732dd795bbe8769d1">GPTimerCC26XX_IntMask</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab667a2fd47273a9778f5011774fa55c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab667a2fd47273a9778f5011774fa55c0">GPTimerCC26XX_Value</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b9b95974e20f85ccd3f8463fdda84f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* GPTimerCC26XX_HwiFxn) (<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> handle, <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac74410bfd92bf89732dd795bbe8769d1">GPTimerCC26XX_IntMask</a> interruptMask)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a415d99f6aca4a4a8bf94a6328021c15c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_g_p_timer_c_c26_x_x___h_w_attrs.html">GPTimerCC26XX_HWAttrs</a>  <a class="el" href="struct_g_p_timer_c_c26_x_x___h_w_attrs.html">GPTimerCC26XX_HWAttrs</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPTimer26XX Hardware attributes. </p>
<p>These fields are used by the driver to set up underlying GPTimer driver statically. A sample structure is shown below:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// GPTimer hardware attributes, one per timer unit (Timer 0A, 0B, 1A, 1B..)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;const GPTimerCC26XX_HWAttrs gptimerCC26xxHWAttrs[CC2650_GPTIMERPARTSCOUNT] = {</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  {.baseAddr = GPT0_BASE, .intNum = INT_TIMER0A, .powerMngrId = PERIPH_GPT0, .pinMux = GPT_PIN_0A, },</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  {.baseAddr = GPT0_BASE, .intNum = INT_TIMER0B, .powerMngrId = PERIPH_GPT0, .pinMux = GPT_PIN_0B, },</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  {.baseAddr = GPT1_BASE, .intNum = INT_TIMER1A, .powerMngrId = PERIPH_GPT1, .pinMux = GPT_PIN_1A, },</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  {.baseAddr = GPT1_BASE, .intNum = INT_TIMER1B, .powerMngrId = PERIPH_GPT1, .pinMux = GPT_PIN_1B, },</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  {.baseAddr = GPT2_BASE, .intNum = INT_TIMER2A, .powerMngrId = PERIPH_GPT2, .pinMux = GPT_PIN_2A, },</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  {.baseAddr = GPT2_BASE, .intNum = INT_TIMER2B, .powerMngrId = PERIPH_GPT2, .pinMux = GPT_PIN_2B, },</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  {.baseAddr = GPT3_BASE, .intNum = INT_TIMER3A, .powerMngrId = PERIPH_GPT3, .pinMux = GPT_PIN_3A, },</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  {.baseAddr = GPT3_BASE, .intNum = INT_TIMER3B, .powerMngrId = PERIPH_GPT3, .pinMux = GPT_PIN_3B, },</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;};</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a98c0a6722f2d48af3b7c032235181bd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_g_p_timer_c_c26_x_x___object.html">GPTimerCC26XX_Object</a>  <a class="el" href="struct_g_p_timer_c_c26_x_x___object.html">GPTimerCC26XX_Object</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPTimer26XX Object. </p>
<p>These fields are used by the driver to store and modify GPTimer configuration during run-time. The application must not edit any member variables of this structure. Appplications should also not access member variables of this structure as backwards compatibility is not guaranteed. An example structure is shown below: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// GPTimer objects, one per full-width timer (A+B) (Timer 0, Timer 1..)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;GPTimerCC26XX_Object gptimerCC26XXObjects[CC2650_GPTIMERCOUNT];</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad5264b3636e1d40a6cbd64cf150be32d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_g_p_timer_c_c26_x_x___params.html">GPTimerCC26XX_Params</a>  <a class="el" href="struct_g_p_timer_c_c26_x_x___params.html">GPTimerCC26XX_Params</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPTimerCC26XX Parameters. </p>
<p>GPTimer parameters are used to with the <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> call. Default values for these parameters are set using <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a11e9f3ff24f5f075989f89d99e65e827" title="Function to initialize the GPTimerCC26XX_Params struct to its default values. ">GPTimerCC26XX_Params_init()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a11e9f3ff24f5f075989f89d99e65e827" title="Function to initialize the GPTimerCC26XX_Params struct to its default values. ">GPTimerCC26XX_Params_init()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a37f7594eb4084eff43d5b80bb6418ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a37f7594eb4084eff43d5b80bb6418ec7">GPTimerCC26XX_Width</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for specifying the GPTimer configuration (width) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a37f7594eb4084eff43d5b80bb6418ec7afbeda4c45001e3d32d50f576d6259016"></a>GPT_CONFIG_32BIT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a37f7594eb4084eff43d5b80bb6418ec7a2e5a3c43a8c62eeace6b38800d39392f"></a>GPT_CONFIG_16BIT&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac3f0539fd948c59b31df04dff5b7024c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac3f0539fd948c59b31df04dff5b7024c">GPTimerCC26XX_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for supported GPTimer modes. Driver code assumes only modes using prescaler as timer extension in 16-bit configuration are used. Therefore new modes must not be added to the below description without also updating driver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac3f0539fd948c59b31df04dff5b7024ca945157a7df9978aef69f2bc5d08328a5"></a>GPT_MODE_ONESHOT_UP&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac3f0539fd948c59b31df04dff5b7024ca0c73c880888fc8da201a44bb87980578"></a>GPT_MODE_PERIODIC_UP&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac3f0539fd948c59b31df04dff5b7024ca8336182ae5bd6521222c07d159b22459"></a>GPT_MODE_EDGE_COUNT_UP&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac3f0539fd948c59b31df04dff5b7024ca3d1702ae14a42f1af112fb88b7fd7c77"></a>GPT_MODE_EDGE_TIME_UP&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac3f0539fd948c59b31df04dff5b7024ca5d09320529435b9b021abd37d4dac117"></a>GPT_MODE_PWM&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a1e0397cdf2412358dfdf0eb0df40db92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a1e0397cdf2412358dfdf0eb0df40db92">GPTimerCC26XX_Interrupt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for supported GPTimer interrupts. GPTimerCC26XX_IntMask arguments should be a bit vector containing these definitions. See description in Technical Reference. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a1e0397cdf2412358dfdf0eb0df40db92a6c6f5236dcbe5f37289a4a513451851e"></a>GPT_INT_TIMEOUT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1e0397cdf2412358dfdf0eb0df40db92a438a33e76043ddb51f1c9e93820a8040"></a>GPT_INT_CAPTURE_MATCH&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1e0397cdf2412358dfdf0eb0df40db92ae3e86fdcf14f9ff34c92aaf953b159d9"></a>GPT_INT_CAPTURE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1e0397cdf2412358dfdf0eb0df40db92a87f843ea54618ca92890d4db7f38f242"></a>GPT_INT_MATCH&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aff5462fa33c306f2c8bd29284fd898b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aff5462fa33c306f2c8bd29284fd898b0">GPTimerCC26XX_Part</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for GPTimer parts (Timer A / Timer B). Used in GPTimer configuration structure GPTimerCC26XX_config to configure the corresponding timer unit. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aff5462fa33c306f2c8bd29284fd898b0a0630f8ce6004469fe81ebbc804e7ac2a"></a>GPT_A&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aff5462fa33c306f2c8bd29284fd898b0a09aae74a0a9878654fa701a70b76387b"></a>GPT_B&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aff5462fa33c306f2c8bd29284fd898b0a492b59ed96b96d5bddcdee40e78712b0"></a>GPT_PARTS_COUNT&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ab4a2e82c659e0ea1fa2ae7a852298359"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4a2e82c659e0ea1fa2ae7a852298359">GPTimerCC26XX_PinMux</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for input / output ports in IO controller to connect GPTimer to a pin. Used in gptimerCC26xxHWAttrs for static timer configuration PIN driver is used to mux a pin to the timer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_p_i_n_c_c26_x_x_8h.html#ac8cbb649db80dd03d8e8a487aef43294" title="Connect pin to HW peripheral, signal or to GPIO. ">PINCC26XX_setMux</a> </dd>
<dd>
GPTimerCC26XX_getPinMux </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab4a2e82c659e0ea1fa2ae7a852298359a46af9b3278d2116fd4862c7fe19624b7"></a>GPT_PIN_0A&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4a2e82c659e0ea1fa2ae7a852298359a1e7ba339de898f1572f21424ce125f2d"></a>GPT_PIN_0B&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4a2e82c659e0ea1fa2ae7a852298359acc7f9d714b4eb87595ebd5a8fdd6ed2f"></a>GPT_PIN_1A&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4a2e82c659e0ea1fa2ae7a852298359a69db29a9a9029d1fcfabfbf20ba26ee4"></a>GPT_PIN_1B&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4a2e82c659e0ea1fa2ae7a852298359a48b2ab2ad9e83e67d94421adb06f4aa1"></a>GPT_PIN_2A&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4a2e82c659e0ea1fa2ae7a852298359a3e1fd803b55127a98c4709cc9e811e70"></a>GPT_PIN_2B&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4a2e82c659e0ea1fa2ae7a852298359a4b93799cba930f4b538d0f0b3bfee4be"></a>GPT_PIN_3A&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4a2e82c659e0ea1fa2ae7a852298359aca82a1cd0f9e891472b4f5b09998a597"></a>GPT_PIN_3B&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ab4c80c79c9acaf8e482e8244adbae73e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4c80c79c9acaf8e482e8244adbae73e">GPTimerCC26XX_DebugMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for controlling timer debug stall mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab4c80c79c9acaf8e482e8244adbae73ea1aca5e7c45ce80046cc86c309b1500b3"></a>GPTimerCC26XX_DEBUG_STALL_OFF&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4c80c79c9acaf8e482e8244adbae73ea78ecad7414438f969450881393850b8c"></a>GPTimerCC26XX_DEBUG_STALL_ON&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac72f25419727329702ec162a2b6b9151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac72f25419727329702ec162a2b6b9151">GPTimerCC26XX_Edge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definitions for controlling edges used for timer capture. Used in GPTimer edge-time and edge-count modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac72f25419727329702ec162a2b6b9151a0dda532d331ac235bead20fad3975f4f"></a>GPTimerCC26XX_POS_EDGE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac72f25419727329702ec162a2b6b9151a2189f990a1c45892bdfcb31855d7d98f"></a>GPTimerCC26XX_NEG_EDGE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac72f25419727329702ec162a2b6b9151a2219c0e15065a692a80b4049036cd20a"></a>GPTimerCC26XX_BOTH_EDGES&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a11e9f3ff24f5f075989f89d99e65e827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPTimerCC26XX_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_g_p_timer_c_c26_x_x___params.html">GPTimerCC26XX_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the <a class="el" href="struct_g_p_timer_c_c26_x_x___params.html" title="GPTimerCC26XX Parameters. ">GPTimerCC26XX_Params</a> struct to its default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>An pointer to <a class="el" href="struct_g_p_timer_c_c26_x_x___params.html" title="GPTimerCC26XX Parameters. ">GPTimerCC26XX_Params</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are:</p><ul>
<li>32-bit configuration</li>
<li>Periodic mode counting upwards</li>
<li>Debug stall mode disabled </li>
</ul>

</div>
</div>
<a class="anchor" id="a30f6c028f0abea0b35c3be3d1609ea9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a> GPTimerCC26XX_open </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_g_p_timer_c_c26_x_x___params.html">GPTimerCC26XX_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into specified mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Logical peripheral number for the GPTimer indexed into the GPTimerCC26XX_config table</td></tr>
    <tr><td class="paramname">params</td><td>Pointer to a parameter block. If NULL, it will use default values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GPTimerCC26XX_Handle on success or a NULL on an error or if it has been opened already. If NULL is returned, further GPTimerCC26XX API calls will result in undefined behaviour.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a0a148f2232f5bb4c59015de965c82d43" title="Function to close a GPTimer peripheral specified by the GPTimer handle. Closing timer will releae dep...">GPTimerCC26XX_close()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0a148f2232f5bb4c59015de965c82d43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPTimerCC26XX_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to close a GPTimer peripheral specified by the GPTimer handle. Closing timer will releae dependency on timer and clear configuration. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first. </dd>
<dd>
<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aebdbd7f83c3824555e4abb7399802765" title="Function to stop the specified GPTimer. ">GPTimerCC26XX_stop()</a> should to be called first if GPTimer is started</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> </dd>
<dd>
<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a869213ede8949245112fd7ca9c9ebdaa" title="Function to start the specified GPTimer with current settings. ">GPTimerCC26XX_start()</a> </dd>
<dd>
<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aebdbd7f83c3824555e4abb7399802765" title="Function to stop the specified GPTimer. ">GPTimerCC26XX_stop()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a869213ede8949245112fd7ca9c9ebdaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPTimerCC26XX_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to start the specified GPTimer with current settings. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first successfully</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> </dd>
<dd>
<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#aebdbd7f83c3824555e4abb7399802765" title="Function to stop the specified GPTimer. ">GPTimerCC26XX_stop()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aebdbd7f83c3824555e4abb7399802765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPTimerCC26XX_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to stop the specified GPTimer. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first successfully</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from <a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> </dd>
<dd>
<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a869213ede8949245112fd7ca9c9ebdaa" title="Function to start the specified GPTimer with current settings. ">GPTimerCC26XX_start()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa365d9e1d6a1b324090510f2748db771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPTimerCC26XX_setLoadValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab667a2fd47273a9778f5011774fa55c0">GPTimerCC26XX_Value</a>&#160;</td>
          <td class="paramname"><em>loadValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set load value of the specified GPTimer. Function can be called while GPTimer is running. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first successfully</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from GPTimerCC26XX_open </td></tr>
    <tr><td class="paramname">loadValue</td><td>Load value to set the GPTimer to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3f83bdcc8482297952f6e08ccadd0e11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPTimerCC26XX_setMatchValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab667a2fd47273a9778f5011774fa55c0">GPTimerCC26XX_Value</a>&#160;</td>
          <td class="paramname"><em>matchValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set match value of the specified GPTimer. Function can be called while GPTimer is running. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first successfully</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from GPTimerCC26XX_open </td></tr>
    <tr><td class="paramname">matchValue</td><td>Match value to set the GPTimer to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae6a091f0962d33a7897ae61b501aedc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPTimerCC26XX_setCaptureEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac72f25419727329702ec162a2b6b9151">GPTimerCC26XX_Edge</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set which input edge the GPTimer capture should use. Applies to edge-count and edge-time modes Function can be called while GPTimer is running. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first successfully</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from GPTimerCC26XX_open </td></tr>
    <tr><td class="paramname">edge</td><td>The edge that should trigger a capture</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af4832251ebc2e81a952bbc1c39d2502e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab667a2fd47273a9778f5011774fa55c0">GPTimerCC26XX_Value</a> GPTimerCC26XX_getFreeRunValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to retrieve the current free-running value of timer. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first successfully</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from GPTimerCC26XX_open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current free-running timer value for all modes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a553ef86139c25234964c81783aa2cd94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab667a2fd47273a9778f5011774fa55c0">GPTimerCC26XX_Value</a> GPTimerCC26XX_getValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to retrieve the current value of timer This returns the value of the timer in all modes except for input edge count and input edge time mode. In edge count mode, this register contains the number of edges that have occurred. In input edge time, this register contains the timer value at which the last edge event took place. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first successfully</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from GPTimerCC26XX_open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current free-running timer value for all modes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4032d544f2b79ae1a999a4faa5ee0884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPTimerCC26XX_registerInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a6b9b95974e20f85ccd3f8463fdda84f1">GPTimerCC26XX_HwiFxn</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac74410bfd92bf89732dd795bbe8769d1">GPTimerCC26XX_IntMask</a>&#160;</td>
          <td class="paramname"><em>intMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to register a CPU interrupt for a given timer handle and enable a set of timer interrupt sources. The interrupt to the CPU will be a bitwise OR of the enabled interrupt sources. When an interrupt occurs, the driver will clear the interrupt source and call the application provided callback. The callback is executed in HW interrupt context and processing in callback should be minimized. </p>
<p>Interrupt sources can also be individually disabled and enabled by using GPTimerCC26XX_enableInterrupt / GPTimerCC26XX_disableInterrupt.</p>
<p>This function should only be called once for a handle after opening the timer. If closing a GPTimer, interrupts for the timer should be unregistered first using GPTimerCC26XX_unregisterInterrupt.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first successfully</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from GPTimerCC26XX_open </td></tr>
    <tr><td class="paramname">callback</td><td>An application provided callback function </td></tr>
    <tr><td class="paramname">intMask</td><td>A bit vector mask containing values from GPTimerCC26XX_Interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open</a> </dd>
<dd>
<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#af08557caa1e95c615a17428521d22d9d" title="Function to enable a set of GPTimer interrupt sources. The interrupt to the CPU must be enabled using...">GPTimerCC26XX_enableInterrupt</a> </dd>
<dd>
<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a8aca62c518c9ff0347ec09f464b88b26" title="Function to disable a set of GPTimer interrupt sources. ">GPTimerCC26XX_disableInterrupt</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adf0a8716a4197bba10d67322c3dfe5ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPTimerCC26XX_unregisterInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to disable a CPU interrupt for a given timer handle and disable all interrupt sources for corresponding GPTimer unit. </p>
<p>This function should only be called once for a handle after opening the timer and registering the interrupt.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first successfully </dd>
<dd>
<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a4032d544f2b79ae1a999a4faa5ee0884" title="Function to register a CPU interrupt for a given timer handle and enable a set of timer interrupt sou...">GPTimerCC26XX_registerInterrupt()</a> has to be called first</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from GPTimerCC26XX_open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open</a> </dd>
<dd>
<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a4032d544f2b79ae1a999a4faa5ee0884" title="Function to register a CPU interrupt for a given timer handle and enable a set of timer interrupt sou...">GPTimerCC26XX_registerInterrupt</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af08557caa1e95c615a17428521d22d9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPTimerCC26XX_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac74410bfd92bf89732dd795bbe8769d1">GPTimerCC26XX_IntMask</a>&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to enable a set of GPTimer interrupt sources. The interrupt to the CPU must be enabled using GPTimerCC26XX_registerInterrupt. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first successfully</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from GPTimerCC26XX_open </td></tr>
    <tr><td class="paramname">interruptMask</td><td>A bit vector mask containing values from GPTimerCC26XX_Interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open</a> </dd>
<dd>
<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a8aca62c518c9ff0347ec09f464b88b26" title="Function to disable a set of GPTimer interrupt sources. ">GPTimerCC26XX_disableInterrupt</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8aca62c518c9ff0347ec09f464b88b26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPTimerCC26XX_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ac74410bfd92bf89732dd795bbe8769d1">GPTimerCC26XX_IntMask</a>&#160;</td>
          <td class="paramname"><em>interruptMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to disable a set of GPTimer interrupt sources. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first successfully</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from GPTimerCC26XX_open </td></tr>
    <tr><td class="paramname">interruptMask</td><td>A bit vector mask containing values from GPTimerCC26XX_Interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open</a> </dd>
<dd>
<a class="el" href="_g_p_timer_c_c26_x_x_8h.html#af08557caa1e95c615a17428521d22d9d" title="Function to enable a set of GPTimer interrupt sources. The interrupt to the CPU must be enabled using...">GPTimerCC26XX_enableInterrupt</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a8bdc7643305d21dcfcd567d215b7f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GPTimerCC26XX_configureDebugStall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab85403dde5940c587c57ca1a140e655a">GPTimerCC26XX_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#ab4c80c79c9acaf8e482e8244adbae73e">GPTimerCC26XX_DebugMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to control timer debug stall mode. When enabled, the timer will stop when the debugger halts the CPU. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open()</a> has to be called first successfully</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A GPTimerCC26XX handle returned from GPTimerCC26XX_open </td></tr>
    <tr><td class="paramname">mode</td><td>Configuration for debug stall mode (enable/disable)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_g_p_timer_c_c26_x_x_8h.html#a30f6c028f0abea0b35c3be3d1609ea9b" title="This function opens a given GPTimer peripheral. Will set dependency on timer and configure it into sp...">GPTimerCC26XX_open</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
Copyright  2018, Texas Instruments Incorporated
</small>
</body>
</html>
